<!DOCTYPE html>
<html><head><meta charset="utf-8"><link rel="stylesheet" type="text/css" media="screen" href="../reports-v2.css"><title>Unicode Locale Data Markup Language (LDML) Part 3: Numbers</title></head><body>




























































































































































































































































































































































<div class="header"><table class="header" cellpadding="0" cellspacing="0" width="100%">
  <tbody>
      <tr>
          <td class="icon"><a href="http://www.unicode.org/"><img style="vertical-align:middle;border:0" alt="[Unicode]" src="http://www.unicode.org/webscripts/logo60s2.gif" height="33" width="34"></a>&nbsp;&nbsp;<a class="bar" href="http://www.unicode.org/reports/">Technical Reports</a></td>
      </tr>
      <tr>
          <td class="gray">&nbsp;</td>
      </tr>
  </tbody>
  </table></div><div class="body"><h2 id="unicode-technical-standard-35">Unicode Technical Standard #35</h2><h1 id="unicode-locale-data-markup-language-ldmlpart-3-numbers">Unicode Locale Data Markup Language (LDML)<br>Part 3: Numbers</h1><!-- HTML: no th --><table class="simple" width="90%"><tbody>
<tr><td>Version</td><td>41</td></tr>
<tr><td>Editors</td><td>Shane F. Carr (<a href="mailto:shane@unicode.org">shane@unicode.org</a>) and <a href="tr35.html#Acknowledgments">other CLDR committee members</a></td></tr>
</tbody></table><p>For the full header, summary, and status, see <a href="tr35.html">Part 1: Core</a>.</p><h3 id="summary"><em>Summary</em></h3><p>This document describes parts of an XML format (<em>vocabulary</em>) for the exchange of structured locale data. This format is used in the <a href="https://unicode.org/cldr/">Unicode Common Locale Data Repository</a>.</p><p>This is a partial document, describing only those parts of the LDML that are relevant for number and currency formatting. For the other parts of the LDML see the <a href="tr35.html">main LDML document</a> and the links above.</p><h3 id="status"><em>Status</em></h3><p><em>This is a draft document which may be updated, replaced, or superseded by other documents at any time. Publication does not imply endorsement by the Unicode Consortium. This is not a stable document; it is inappropriate to cite this document as other than a work in progress.</em></p><blockquote>
<p><em><strong>A Unicode Technical Standard (UTS)</strong> is an independent specification. Conformance to the Unicode Standard does not imply conformance to any UTS.</em></p>
</blockquote><p><em>Please submit corrigenda and other comments with the CLDR bug reporting form [<a href="tr35.html#Bugs">Bugs</a>]. Related information that is useful in understanding this document is found in the <a href="tr35.html#References">References</a>. For the latest version of the Unicode Standard see [<a href="tr35.html#Unicode">Unicode</a>]. For a list of current Unicode Technical Reports see [<a href="tr35.html#Reports">Reports</a>]. For more information about versions of the Unicode Standard, see [<a href="tr35.html#Versions">Versions</a>].</em></p><h2 id="parts"><a name="Parts" href="#Parts">Parts</a></h2><p>The LDML specification is divided into the following parts:</p><ul>
<li>  Part 1: <a href="tr35.html#Contents">Core</a> (languages, locales, basic structure)</li>
<li>  Part 2: <a href="tr35-general.html#Contents">General</a> (display names &amp; transforms, etc.)</li>
<li>  Part 3: <a href="tr35-numbers.html#Contents">Numbers</a> (number &amp; currency formatting)</li>
<li>  Part 4: <a href="tr35-dates.html#Contents">Dates</a> (date, time, time zone formatting)</li>
<li>  Part 5: <a href="tr35-collation.html#Contents">Collation</a> (sorting, searching, grouping)</li>
<li>  Part 6: <a href="tr35-info.html#Contents">Supplemental</a> (supplemental data)</li>
<li>  Part 7: <a href="tr35-keyboards.html#Contents">Keyboards</a> (keyboard mappings)</li>
</ul><h2 id="contents-of-part-3-numbers"><a name="Contents" href="#Contents">Contents of Part 3, Numbers</a></h2><ul>
<li>  1 <a href="#Numbering_Systems">Numbering Systems</a></li>
<li>2 <a href="#Number_Elements">Number Elements</a><ul>
<li>  2.1 <a href="#defaultNumberingSystem">Default Numbering System</a></li>
<li>  2.2 <a href="#otherNumberingSystems">Other Numbering Systems</a></li>
<li>  2.3 <a href="#Number_Symbols">Number Symbols</a></li>
<li>2.4 <a href="#Number_Formats">Number Formats</a><ul>
<li>  2.4.1 <a href="#Compact_Number_Formats">Compact Number Formats</a></li>
<li>  2.4.2 <a href="#Currency_Formats">Currency Formats</a></li>
</ul>
</li>
<li>  2.5 <a href="#Miscellaneous_Patterns">Miscellaneous Patterns</a></li>
<li>  2.6 <a href="#Minimal_Pairs">Minimal Pairs</a></li>
</ul>
</li>
<li>3 <a href="#Number_Format_Patterns">Number Format Patterns</a><ul>
<li>3.1 <a href="#Number_Patterns">Number Patterns</a><ul>
<li>  Table: <a href="#Number_Pattern_Examples">Number Pattern Examples</a></li>
</ul>
</li>
<li>3.2 <a href="#Special_Pattern_Characters">Special Pattern Characters</a><ul>
<li>  Table: <a href="#Number_Pattern_Character_Definitions">Number Pattern Character Definitions</a></li>
<li>  Table: <a href="#Sample_Patterns_and_Results">Sample Patterns and Results</a></li>
<li>  Table: <a href="#Examples_of_minimumGroupingDigits">Examples of minimumGroupingDigits</a></li>
<li>  3.2.1 <a href="#Explicit_Plus">Explicit Plus Signs</a></li>
</ul>
</li>
<li>  3.3 <a href="#Formatting">Formatting</a></li>
<li>  3.4 <a href="#sci">Scientific Notation</a></li>
<li>3.5 <a href="#sigdig">Significant Digits</a><ul>
<li>  Table: <a href="#Significant_Digits_Examples">Significant Digits Examples</a></li>
</ul>
</li>
<li>  3.6 <a href="#Padding">Padding</a></li>
<li>  3.7 <a href="#Rounding">Rounding</a></li>
<li>  3.8 <a href="#Quoting_Rules">Quoting Rules</a></li>
</ul>
</li>
<li>4 <a href="#Currencies">Currencies</a><ul>
<li>  4.1 <a href="#Supplemental_Currency_Data">Supplemental Currency Data</a></li>
</ul>
</li>
<li>5 <a href="#Language_Plural_Rules">Language Plural Rules</a><ul>
<li>5.1 <a href="#Plural_rules_syntax">Plural rules syntax</a><ul>
<li>5.1.1 <a href="#Operands">Operands</a><ul>
<li>  Table: <a href="#Plural_Operand_Meanings">Plural Operand Meanings</a></li>
<li>  Table: <a href="#Plural_Operand_Examples">Plural Operand Examples</a></li>
</ul>
</li>
<li>5.1.2 <a href="#Relations">Relations</a><ul>
<li>  Table: <a href="#Relations_Examples">Relations Examples</a></li>
<li>  Table: <a href="#Plural_Rules_Examples">Plural Rules Examples</a></li>
</ul>
</li>
<li>5.1.3 <a href="#Samples">Samples</a><ul>
<li>  Table: <a href="#Plural_Samples_Examples">Plural Samples Examples</a></li>
</ul>
</li>
<li>  5.1.4 <a href="#Using_cardinals">Using Cardinals</a></li>
</ul>
</li>
<li>  5.2 <a href="#Plural_Ranges">Plural Ranges</a></li>
</ul>
</li>
<li>  6 <a href="#Rule-Based_Number_Formatting">Rule-Based Number Formatting</a></li>
<li>  7 <a href="#Parsing_Numbers">Parsing Numbers</a></li>
</ul><h2 id="1-numbering-systems">1 <a name="Numbering_Systems" href="#Numbering_Systems">Numbering Systems</a></h2><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">numberingSystems</span> ( <span class="hljs-meta-keyword">numberingSystem</span>* ) &gt;</span>  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">numberingSystem</span> <span class="hljs-meta-keyword">EMPTY</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">numberingSystem</span> <span class="hljs-meta-keyword">id</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">numberingSystem</span> <span class="hljs-meta-keyword">type</span> ( <span class="hljs-meta-keyword">numeric</span> | <span class="hljs-meta-keyword">algorithmic</span> ) <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">numberingSystem</span> <span class="hljs-meta-keyword">radix</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">numberingSystem</span> <span class="hljs-meta-keyword">digits</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">numberingSystem</span> <span class="hljs-meta-keyword">rules</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
</code></pre><p>Numbering systems information is used to define different representations for numeric values to an end user. Numbering systems are defined in CLDR as one of two different types: algorithmic and numeric. Numeric systems are simply a decimal based system that uses a predefined set of digits to represent numbers. Examples are Western ( ASCII digits ), Thai digits, Devanagari digits. Algorithmic systems are more complex in nature, since the proper formatting and presentation of a numeric quantity is based on some algorithm or set of rules. Examples are Chinese numerals, Hebrew numerals, or Roman numerals. In CLDR, the rules for presentation of numbers in an algorithmic system are defined using the RBNF syntax described in <em><a href="#Rule-Based_Number_Formatting">Section 6: Rule-Based Number Formatting</a></em>.</p><p>Attributes for the <code>&lt;numberingSystem&gt;</code> element are as follows:</p><ul>
<li><code>id</code> - Specifies the name of the numbering system that can be used to designate its use in formatting.</li>
<li><code>type</code> - Specifies whether the numbering system is algorithmic or numeric.</li>
<li><code>digits</code> - For numeric systems, specifies the digits used to represent numbers, in order, starting from zero.</li>
<li><code>rules</code> - Specifies the RBNF ruleset to be used for formatting numbers from this numbering system. The rules specifier can contain simply a ruleset name, in which case the ruleset is assumed to be found in the rule set grouping "NumberingSystemRules". Alternatively, the specifier can denote a specific locale, ruleset grouping, and ruleset name, separated by slashes.</li>
</ul><p>Examples:</p><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- ASCII digits - A numeric system --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">numberingSystem</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"latn"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"numeric"</span> <span class="hljs-attr">digits</span>=<span class="hljs-string">"0123456789"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- A numeric system using Thai digits --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">numberingSystem</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"thai"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"numeric"</span> <span class="hljs-attr">digits</span>=<span class="hljs-string">"๐๑๒๓๔๕๖๗๘๙"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- An algorithmic system - Georgian numerals , rules found in NumberingSystemRules --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">numberingSystem</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"geor"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"algorithmic"</span> <span class="hljs-attr">rules</span>=<span class="hljs-string">"georgian"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- An algorithmic system. Traditional Chinese Numerals --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">numberingSystem</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"hant"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"algorithmic"</span> <span class="hljs-attr">rules</span>=<span class="hljs-string">"zh_Hant/SpelloutRules/spellout-cardinal"</span>/&gt;</span>
</code></pre><p>For general information about the numbering system data, including the BCP47 identifiers, see the main document <em>Section Q.1.1 <a href="tr35.html#Numbering%20System%20Data">Numbering System Data</a>.</em></p><h2 id="2-number-elements">2 <a name="Number_Elements" href="#Number_Elements">Number Elements</a></h2><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">numbers</span> ( <span class="hljs-meta-keyword">alias</span> | ( <span class="hljs-meta-keyword">defaultNumberingSystem</span>*, <span class="hljs-meta-keyword">otherNumberingSystems</span>*, <span class="hljs-meta-keyword">minimumGroupingDigits</span>*, <span class="hljs-meta-keyword">symbols</span>*, <span class="hljs-meta-keyword">decimalFormats</span>*, <span class="hljs-meta-keyword">scientificFormats</span>*, <span class="hljs-meta-keyword">percentFormats</span>*, <span class="hljs-meta-keyword">currencyFormats</span>*, <span class="hljs-meta-keyword">currencies</span>?, <span class="hljs-meta-keyword">miscPatterns</span>*, <span class="hljs-meta-keyword">minimalPairs</span>*, <span class="hljs-meta-keyword">special</span>* ) ) &gt;</span>
</code></pre><p>The numbers element supplies information for formatting and parsing numbers and currencies. It has the following sub-elements: <code>&lt;defaultNumberingSystem&gt;</code>, <code>&lt;otherNumberingSystems&gt;</code>, <code>&lt;symbols&gt;</code>, <code>&lt;decimalFormats&gt;</code>, <code>&lt;scientificFormats&gt;</code>, <code>&lt;percentFormats&gt;</code>, <code>&lt;currencyFormats&gt;</code>, and <code>&lt;currencies&gt;</code>. The currency IDs are from [<a href="tr35.html#ISO4217">ISO4217</a>] (plus some additional common-use codes). For more information, including the pattern structure, see <em><a href="#Number_Format_Patterns">Section 3: Number Format Patterns</a></em>.</p><h3 id="21-default-numbering-system">2.1 <a name="defaultNumberingSystem" href="#defaultNumberingSystem">Default Numbering System</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">defaultNumberingSystem</span> ( <span class="hljs-meta-keyword">#PCDATA</span> )&gt;</span>
</code></pre><p>This element indicates which numbering system should be used for presentation of numeric quantities in the given locale.</p><h3 id="22-other-numbering-systems">2.2 <a name="otherNumberingSystems" href="#otherNumberingSystems">Other Numbering Systems</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">otherNumberingSystems</span> ( <span class="hljs-meta-keyword">alias</span> | ( <span class="hljs-meta-keyword">native</span>*, <span class="hljs-meta-keyword">traditional</span>*, <span class="hljs-meta-keyword">finance</span>*)) &gt;</span>
</code></pre><p>This element defines general categories of numbering systems that are sometimes used in the given locale for formatting numeric quantities. These additional numbering systems are often used in very specific contexts, such as in calendars or for financial purposes. There are currently three defined categories, as follows:</p><p><strong>native</strong></p><blockquote>
<p>Defines the numbering system used for the native digits, usually defined as a part of the script used to write the language. The native numbering system can only be a numeric positional decimal-digit numbering system, using digits with General_Category=Decimal_Number. Note: In locales where the native numbering system is the default, it is assumed that the numbering system "latn" ( Western Digits 0-9 ) is always acceptable, and can be selected using the -nu keyword as part of a Unicode locale identifier.</p>
</blockquote><p><strong>traditional</strong></p><blockquote>
<p>Defines the traditional numerals for a locale. This numbering system may be numeric or algorithmic. If the traditional numbering system is not defined, applications should use the native numbering system as a fallback.</p>
</blockquote><p><strong>finance</strong></p><blockquote>
<p>Defines the numbering system used for financial quantities. This numbering system may be numeric or algorithmic. This is often used for ideographic languages such as Chinese, where it would be easy to alter an amount represented in the default numbering system simply by adding additional strokes. If the financial numbering system is not specified, applications should use the default numbering system as a fallback.</p>
</blockquote><p>The categories defined for other numbering systems can be used in a Unicode locale identifier to select the proper numbering system without having to know the specific numbering system by name. For example:</p><ul>
<li>  To select Hindi language using the native digits for numeric formatting, use locale ID: "hi-IN-u-nu-native".</li>
<li>  To select Chinese language using the appropriate financial numerals, use locale ID: "zh-u-nu-finance".</li>
<li>  To select Tamil language using the traditional Tamil numerals, use locale ID: "ta-u-nu-traditio".</li>
<li>  To select Arabic language using western digits 0-9, use locale ID: "ar-u-nu-latn".</li>
</ul><p>For more information on numbering systems and their definitions, see <em><a href="#Numbering_Systems">Section 1: Numbering Systems</a></em>.</p><h3 id="23-number-symbols">2.3 <a name="Number_Symbols" href="#Number_Symbols">Number Symbols</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">symbols</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">decimal</span>*, <span class="hljs-meta-keyword">group</span>*, <span class="hljs-meta-keyword">list</span>*, <span class="hljs-meta-keyword">percentSign</span>*, <span class="hljs-meta-keyword">nativeZeroDigit</span>*, <span class="hljs-meta-keyword">patternDigit</span>*, <span class="hljs-meta-keyword">plusSign</span>*, <span class="hljs-meta-keyword">minusSign</span>*, <span class="hljs-meta-keyword">approximatelySign</span>*, <span class="hljs-meta-keyword">exponential</span>*, <span class="hljs-meta-keyword">superscriptingExponent</span>*, <span class="hljs-meta-keyword">perMille</span>*, <span class="hljs-meta-keyword">infinity</span>*, <span class="hljs-meta-keyword">nan</span>*, <span class="hljs-meta-keyword">currencyDecimal</span>*, <span class="hljs-meta-keyword">currencyGroup</span>*, <span class="hljs-meta-keyword">timeSeparator</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
</code></pre><p>Number symbols define the localized symbols that are commonly used when formatting numbers in a given locale. These symbols can be referenced using a number formatting pattern as defined in <em><a href="#Number_Format_Patterns">Section 3: Number Format Patterns</a></em>.</p><p>The available number symbols are as follows:</p><p><strong>decimal</strong></p><blockquote>
<p>separates the integer and fractional part of the number.</p>
</blockquote><p><strong>group</strong></p><blockquote>
<p>separates clusters of integer digits to make large numbers more legible; commonly used for thousands (grouping size 3, e.g. "100,000,000") or in some locales, ten-thousands (grouping size 4, e.g. "1,0000,0000"). There may be two different grouping sizes: The <em>primary grouping size</em> used for the least significant integer group, and the <em>secondary grouping size</em> used for more significant groups; these are not the same in all locales (e.g. "12,34,56,789"). If a pattern contains multiple grouping separators, the interval between the last one and the end of the integer defines the primary grouping size, and the interval between the last two defines the secondary grouping size. All others are ignored, so "#,##,###,####" == "###,###,####" == "##,#,###,####".</p>
</blockquote><p><strong>list</strong></p><blockquote>
<p>symbol used to separate numbers in a list intended to represent structured data such as an array; must be different from the <strong>decimal</strong> value. This list separator is for “non-linguistic” usage as opposed to the listPatterns for “linguistic” lists (e.g. “Bob, Carol, and Ted”) described in Part 2, <em>Section 11 <a href="tr35-general.html#ListPatterns">List Patterns</a></em>.</p>
</blockquote><p><strong>percentSign</strong></p><blockquote>
<p>symbol used to indicate a percentage (1/100th) amount. (If present, the value is also multiplied by 100 before formatting. That way 1.23 → 123%)</p>
</blockquote><p><del><strong>nativeZeroDigit</strong></del></p><blockquote>
<p>Deprecated - do not use.</p>
</blockquote><p><del><strong>patternDigit</strong></del></p><blockquote>
<p>Deprecated. This was formerly used to provide the localized pattern character corresponding to '#', but localization of the pattern characters themselves has been deprecated for some time (determining the locale-specific <em>replacements</em> for pattern characters is of course not deprecated and is part of normal number formatting).</p>
</blockquote><p><strong>minusSign</strong></p><blockquote>
<p>Symbol used to denote negative value.</p>
</blockquote><p><strong>plusSign</strong></p><blockquote>
<p>Symbol used to denote positive value.  It can be used to produce modified patterns, so that 3.12 is formatted as "+3.12", for example. The standard number patterns (except for type="accounting") will contain the minusSign, explicitly or implicitly. In the explicit pattern, the value of the plusSign can be substituted for the value of the minusSign to produce a pattern that has an explicit plus sign.</p>
</blockquote><p><strong>approximatelySign</strong></p><blockquote>
<p>Symbol used to denote a value that is approximate but not exact. The symbol is substituted in place of the minusSign using the same semantics as plusSign substitution.</p>
</blockquote><p><strong>exponential</strong></p><blockquote>
<p>Symbol separating the mantissa and exponent values.</p>
</blockquote><p><strong>superscriptingExponent</strong></p><blockquote>
<p>(Programmers are used to the fallback exponent style “1.23E4”, but that should not be shown to end-users. Instead, the exponential notation superscriptingExponent should be used to show a format like “1.23 × 104”. ) The superscripting can use markup, such as <code>&lt;sup&gt;4&lt;/sup&gt;</code> in HTML, or for the special case of Latin digits, use the superscript characters: U+207B ( ⁻ ), U+2070 ( ⁰ ), U+00B9 ( ¹ ), U+00B2 ( ² ), U+00B3 ( ³ ), U+2074 ( ⁴ ) .. U+2079 ( ⁹ ).</p>
</blockquote><p><strong>perMille</strong></p><blockquote>
<p>symbol used to indicate a per-mille (1/1000th) amount. (If present, the value is also multiplied by 1000 before formatting. That way 1.23 → 1230 [1/000])</p>
</blockquote><p><strong>infinity</strong></p><blockquote>
<p>The infinity sign. Corresponds to the IEEE infinity bit pattern.</p>
</blockquote><p><strong>nan - Not a number</strong></p><blockquote>
<p>The NaN sign. Corresponds to the IEEE NaN bit pattern.</p>
</blockquote><p><strong>currencyDecimal</strong></p><blockquote>
<p>Optional. If specified, then for currency formatting/parsing this is used as the decimal separator instead of using the regular decimal separator; otherwise, the regular decimal separator is used.</p>
</blockquote><p><strong>currencyGroup</strong></p><blockquote>
<p>Optional. If specified, then for currency formatting/parsing this is used as the group separator instead of using the regular group separator; otherwise, the regular group separator is used.</p>
</blockquote><p><strong>timeSeparator</strong></p><blockquote>
<p>This replaces any use of the timeSeparator pattern character in a date-time format pattern (no timeSeparator pattern character is currently defined, see note below). This allows the same time format to be used for multiple number systems when the time separator depends on the number system. For example, the time format for Arabic should be COLON when using the Latin numbering system (0, 1, 2, …), but when the Arabic numbering system is used (٠‎ - ١‎ - ٢‎ …), the traditional time separator in older print styles was often ARABIC COMMA.</p>
<p><strong>Note:</strong> In CLDR 26 the timeSeparator pattern character was specified to be COLON. This was withdrawn in CLDR 28 due to backward compatibility issues, and no timeSeparator pattern character is currently defined. No CLDR locales are known to have a need to specify timeSeparator symbols that depend on number system; if this changes in the future a different timeSeparator pattern character will be defined. In the meantime, since CLDR data consumers can still request the timeSeparator symbol. it should match the symbol actually used in the <a href="tr35-dates.html#timeFormats">timeFormats</a> and <a href="tr35-dates.html#availableFormats_appendItems">availableFormats</a> items.</p>
</blockquote><p>Example:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">symbols</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">decimal</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">decimal</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>,<span class="hljs-tag">&lt;/<span class="hljs-name">group</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>;<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">percentSign</span>&gt;</span>%<span class="hljs-tag">&lt;/<span class="hljs-name">percentSign</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">patternDigit</span>&gt;</span>#<span class="hljs-tag">&lt;/<span class="hljs-name">patternDigit</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plusSign</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">plusSign</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">minusSign</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">minusSign</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">approximatelySign</span>&gt;</span>~<span class="hljs-tag">&lt;/<span class="hljs-name">approximatelySign</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exponential</span>&gt;</span>E<span class="hljs-tag">&lt;/<span class="hljs-name">exponential</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">superscriptingExponent</span>&gt;</span>×<span class="hljs-tag">&lt;/<span class="hljs-name">superscriptingExponent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">perMille</span>&gt;</span>‰<span class="hljs-tag">&lt;/<span class="hljs-name">perMille</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">infinity</span>&gt;</span>∞<span class="hljs-tag">&lt;/<span class="hljs-name">infinity</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">nan</span>&gt;</span>☹<span class="hljs-tag">&lt;/<span class="hljs-name">nan</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">timeSeparator</span>&gt;</span>:<span class="hljs-tag">&lt;/<span class="hljs-name">timeSeparator</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">symbols</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">symbols</span> <span class="hljs-meta-keyword">numberSystem</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
</code></pre><p>The <code>numberSystem</code> attribute is used to specify that the given number symbols are to be used when the given numbering system is active. Number symbols can only be defined for numbering systems of the "numeric" type, since any special symbols required for an algorithmic numbering system should be specified by the RBNF formatting rules used for that numbering system. By default, number symbols without a specific <code>numberSystem</code> attribute are assumed to be used for the "latn" numbering system, which is western (ASCII) digits. Locales that specify a numbering system other than "latn" as the default should also specify number formatting symbols that are appropriate for use within the context of the given numbering system. For example, a locale that uses the Arabic-Indic digits as its default would likely use an Arabic comma for the grouping separator rather than the ASCII comma.<br>For more information on numbering systems and their definitions, see <em><a href="#Numbering_Systems">Section 1: Numbering Systems</a></em>.</p><h3 id="24-number-formats">2.4 <a name="Number_Formats" href="#Number_Formats">Number Formats</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">decimalFormats</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">default</span>*, <span class="hljs-meta-keyword">decimalFormatLength</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">decimalFormatLength</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">default</span>*, <span class="hljs-meta-keyword">decimalFormat</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">decimalFormatLength</span> <span class="hljs-meta-keyword">type</span> ( <span class="hljs-meta-keyword">full</span> | <span class="hljs-meta-keyword">long</span> | <span class="hljs-meta-keyword">medium</span> | <span class="hljs-meta-keyword">short</span> ) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">decimalFormat</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">pattern</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
</code></pre><p>(scientificFormats, percentFormats have the same structure)</p><p>Number formats are used to define the rules for formatting numeric quantities using the pattern syntax described in <em><a href="#Number_Format_Patterns">Section 3: Number Format Patterns</a></em>.</p><p>Different formats are provided for different contexts, as follows:</p><p><strong>decimalFormats</strong></p><blockquote>
<p>The normal locale specific way to write a base 10 number. Variations of the decimalFormat pattern are provided that allow compact number formatting.</p>
</blockquote><p><strong>percentFormats</strong></p><blockquote>
<p>Pattern for use with percentage formatting</p>
</blockquote><p><strong>scientificFormats</strong></p><blockquote>
<p>Pattern for use with scientific (exponent) formatting.</p>
</blockquote><p>Example:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">decimalFormats</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">decimalFormatLength</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"long"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">decimalFormat</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>#,##0.###<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">decimalFormat</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">decimalFormatLength</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">decimalFormats</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">scientificFormats</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">default</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"long"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scientificFormatLength</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"long"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scientificFormat</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>0.000###E+00<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">scientificFormat</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">scientificFormatLength</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scientificFormatLength</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"medium"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scientificFormat</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>0.00##E+00<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">scientificFormat</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">scientificFormatLength</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">scientificFormats</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">percentFormats</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">percentFormatLength</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"long"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">percentFormat</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>#,##0%<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">percentFormat</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">percentFormatLength</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">percentFormats</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">symbols</span> <span class="hljs-meta-keyword">numberSystem</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
</code></pre><p>The <code>numberSystem</code> attribute is used to specify that the given number formatting pattern(s) are to be used when the given numbering system is active. By default, number formatting patterns without a specific <code>numberSystem</code> attribute are assumed to be used for the "latn" numbering system, which is western (ASCII) digits. Locales that specify a numbering system other than "latn" as the default should also specify number formatting patterns that are appropriate for use within the context of the given numbering system.<br>For more information on numbering systems and their definitions, see <em><a href="#Numbering_Systems">Section 1: Numbering Systems</a></em>.</p><h4 id="241-compact-number-formats">2.4.1 <a name="Compact_Number_Formats" href="#Compact_Number_Formats">Compact Number Formats</a></h4><p>A pattern <code>type</code> attribute is used for <em>compact number formats</em>, such as the following:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">decimalFormatLength</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"long"</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">decimalFormat</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>0 millier<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>0 milliers<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>00 mille<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>00 mille<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"100000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>000 mille<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"100000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>000 mille<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>0 million<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>0 millions<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        …  
    <span class="hljs-tag">&lt;/<span class="hljs-name">decimalFormat</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">decimalFormatLength</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">decimalFormatLength</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"short"</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">decimalFormat</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>0 K<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>0 K<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>00 K<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>00 K<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"100000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>000 K<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"100000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>000 K<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>0 M<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>0 M<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        …  
    <span class="hljs-tag">&lt;/<span class="hljs-name">decimalFormat</span>&gt;</span>
…
<span class="hljs-tag">&lt;<span class="hljs-name">currencyFormatLength</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"short"</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">currencyFormat</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"standard"</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>0 K ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>0 K ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>00 K ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>00 K ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"100000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>000 K ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"100000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>000 K ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>0 M ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"1000000"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>0 M ¤<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
</code></pre><p>Formats can be supplied for numbers (as above) or for currencies or other units. They can also be used with ranges of numbers, resulting in formatting strings like “$10K” or “$3–7M”.</p><p>To format a number N, the greatest type less than or equal to N is used, with the appropriate plural category. N is divided by the type, after removing the number of zeros in the pattern, less 1. APIs supporting this format should provide control over the number of significant or fraction digits.</p><p>The default pattern for any type that is not supplied is the special value “0”, as in the following. The value “0” must be used when a child locale overrides a parent locale to drop the compact pattern for that type and use the default pattern.</p><p> <code>&lt;pattern type="1" count="one"&gt;0&lt;/pattern&gt;</code></p><p>If the value is precisely “0”, either explicit or defaulted, then the normal number format pattern for that sort of object is supplied — either <code>&lt;decimalFormat&gt;</code> or <code>&lt;currencyFormat type="standard"&gt;</code> — with the normal formatting for the locale (such as the grouping separators). However, for the “0” case by default the signficant digits are adjusted for consistency, typically to 2 or 3 digits, and the maximum fractional digits are set to 0 (for both currencies and plain decimal). Thus the output would be $12, not $12.01. APIs may, however, allow these default behaviors to be overridden.</p><p>With the data above, N=12345 matches <code>&lt;pattern type="10000" count="other"&gt;00 K&lt;/pattern&gt;</code>. N is divided by 1000 (obtained from10000 after removing "00" and restoring one "0". The result is formatted according to the normal decimal pattern. With no fractional digits, that yields "12 K".</p><p>Formatting 1200 in USD would result in “1.2 K $”, while 990 implicitly maps to the special value “0”, which maps to <code>&lt;currencyFormat type="standard"&gt;&lt;pattern&gt;#,##0.00 ¤&lt;/pattern&gt;</code>, and would result in simply “990 $”.</p><p>The short format is designed for UI environments where space is at a premium, and should ideally result in a formatted string no more than about 6 em wide (with no fractional digits).</p><h4 id="242-currency-formats">2.4.2 <a name="Currency_Formats" href="#Currency_Formats">Currency Formats</a></h4><p>Pattern for use with currency formatting. This format contains a few additional structural options that allow proper placement of the currency symbol relative to the numeric quantity. Refer to <em><a href="#Currencies">Section 4 - Currencies</a></em> for additional information on the use of these options.</p><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currencyFormats</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">default</span>*, <span class="hljs-meta-keyword">currencySpacing</span>*, <span class="hljs-meta-keyword">currencyFormatLength</span>*, <span class="hljs-meta-keyword">unitPattern</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currencySpacing</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">beforeCurrency</span>*, <span class="hljs-meta-keyword">afterCurrency</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">beforeCurrency</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">currencyMatch</span>*, <span class="hljs-meta-keyword">surroundingMatch</span>*, <span class="hljs-meta-keyword">insertBetween</span>*)) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">afterCurrency</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">currencyMatch</span>*, <span class="hljs-meta-keyword">surroundingMatch</span>*, <span class="hljs-meta-keyword">insertBetween</span>*)) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currencyMatch</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">surroundingMatch</span> ( <span class="hljs-meta-keyword">#PCDATA</span> )) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">insertBetween</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currencyFormatLength</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">default</span>*, <span class="hljs-meta-keyword">currencyFormat</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">currencyFormatLength</span> <span class="hljs-meta-keyword">type</span> ( <span class="hljs-meta-keyword">full</span> | <span class="hljs-meta-keyword">long</span> | <span class="hljs-meta-keyword">medium</span> | <span class="hljs-meta-keyword">short</span> ) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currencyFormat</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">pattern</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>
</code></pre><p>In addition to a standard currency format, in which negative currency amounts might typically be displayed as something like “-$3.27”, locales may provide an "accounting" form, in which for "en_US" the same example would appear as “($3.27)”.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">currencyFormats</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currencyFormatLength</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">currencyFormat</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"standard"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>¤#,##0.00<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">currencyFormat</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">currencyFormat</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"accounting"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>¤#,##0.00;(¤#,##0.00)<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">currencyFormat</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">currencyFormatLength</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">currencyFormats</span>&gt;</span>
</code></pre><h3 id="25-miscellaneous-patterns">2.5 <a name="Miscellaneous_Patterns" href="#Miscellaneous_Patterns">Miscellaneous Patterns</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">miscPatterns</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">default</span>*, <span class="hljs-meta-keyword">pattern</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">miscPatterns</span> <span class="hljs-meta-keyword">numberSystem</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>
</code></pre><p>The miscPatterns supply additional patterns for special purposes. The currently defined values are:</p><p><strong>approximately</strong></p><blockquote>
<p>indicates an approximate number, such as: “~99”</p>
</blockquote><p><strong>atMost</strong></p><blockquote>
<p>indicates a number or lower, such as: “<code>≤</code>99” to indicate that there are 99 items or fewer.</p>
</blockquote><p><strong>atLeast</strong></p><blockquote>
<p>indicates a number or higher, such as: “99+” to indicate that there are 99 items or more.</p>
</blockquote><p><strong>range</strong></p><blockquote>
<p>indicates a range of numbers, such as: “99–103” to indicate that there are from 99 to 103 items.</p>
</blockquote><p><em>For example:</em></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">miscPatterns</span> <span class="hljs-attr">numberSystem</span>=<span class="hljs-string">"…"</span>&gt;</span>  
  <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"approximately"</span>&gt;</span>~{0}<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
  <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"atLeast"</span>&gt;</span>≥{0}<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
  <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"atMost"</span>&gt;</span>≤{0}<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
  <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"range"</span>&gt;</span>{0}–{1}<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">miscPatterns</span>&gt;</span>
</code></pre><h3 id="26-minimal-pairs">2.6 <a name="Minimal_Pairs" href="#Minimal_Pairs">Minimal Pairs</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">minimalPairs</span> ( <span class="hljs-meta-keyword">alias</span> | ( <span class="hljs-meta-keyword">pluralMinimalPairs</span>*, <span class="hljs-meta-keyword">ordinalMinimalPairs</span>*, <span class="hljs-meta-keyword">caseMinimalPairs</span>*, <span class="hljs-meta-keyword">genderMinimalPairs</span>*, <span class="hljs-meta-keyword">special</span>* ) ) &gt;</span>  
</code></pre><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">pluralMinimalPairs</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">pluralMinimalPairs</span> <span class="hljs-meta-keyword">count</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
</code></pre><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">ordinalMinimalPairs</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">ordinalMinimalPairs</span> <span class="hljs-meta-keyword">ordinal</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
</code></pre><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">caseMinimalPairs</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">caseMinimalPairs</span> <span class="hljs-meta-keyword">case</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">genderMinimalPairs</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">genderMinimalPairs</span> <span class="hljs-meta-keyword">gender</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>
</code></pre><p>Minimal pairs provide examples that justify why multiple plural or ordinal categories exist, and for providing contextual examples for verifying consistency of translations. The allowable values for the <code>count</code>, <code>ordinal</code>, <code>case</code>, and <code>gender</code> attributes are found in the dtd file.</p><p>Examples</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">minimalPairs</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">pluralMinimalPairs</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>{0} Tag<span class="hljs-tag">&lt;/<span class="hljs-name">pluralMinimalPairs</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">pluralMinimalPairs</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>{0} Tage<span class="hljs-tag">&lt;/<span class="hljs-name">pluralMinimalPairs</span>&gt;</span>  
  
    <span class="hljs-tag">&lt;<span class="hljs-name">ordinalMinimalPairs</span> <span class="hljs-attr">ordinal</span>=<span class="hljs-string">"other"</span>&gt;</span>{0}. Abzweigung nach rechts nehmen<span class="hljs-tag">&lt;/<span class="hljs-name">ordinalMinimalPairs</span>&gt;</span>  
  
    <span class="hljs-tag">&lt;<span class="hljs-name">caseMinimalPairs</span> <span class="hljs-attr">case</span>=<span class="hljs-string">"accusative"</span>&gt;</span>… für {0} …<span class="hljs-tag">&lt;/<span class="hljs-name">caseMinimalPairs</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">caseMinimalPairs</span> <span class="hljs-attr">case</span>=<span class="hljs-string">"dative"</span>&gt;</span>… mit {0} …<span class="hljs-tag">&lt;/<span class="hljs-name">caseMinimalPairs</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">caseMinimalPairs</span> <span class="hljs-attr">case</span>=<span class="hljs-string">"genitive"</span>&gt;</span>Anstatt {0} …<span class="hljs-tag">&lt;/<span class="hljs-name">caseMinimalPairs</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">caseMinimalPairs</span> <span class="hljs-attr">case</span>=<span class="hljs-string">"nominative"</span>&gt;</span>{0} kostet (kosten) € 3,50.<span class="hljs-tag">&lt;/<span class="hljs-name">caseMinimalPairs</span>&gt;</span>  
  
    <span class="hljs-tag">&lt;<span class="hljs-name">genderMinimalPairs</span> <span class="hljs-attr">gender</span>=<span class="hljs-string">"feminine"</span>&gt;</span>Die {0} ist …<span class="hljs-tag">&lt;/<span class="hljs-name">genderMinimalPairs</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">genderMinimalPairs</span> <span class="hljs-attr">gender</span>=<span class="hljs-string">"masculine"</span>&gt;</span>Der {0} ist …<span class="hljs-tag">&lt;/<span class="hljs-name">genderMinimalPairs</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">genderMinimalPairs</span> <span class="hljs-attr">gender</span>=<span class="hljs-string">"neuter"</span>&gt;</span>Das {0} ist …<span class="hljs-tag">&lt;/<span class="hljs-name">genderMinimalPairs</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">minimalPairs</span>&gt;</span>
</code></pre><p>For more information, see <a href="http://cldr.unicode.org/index/cldr-spec/plural-rules">Plural Rules</a> and <a href="http://cldr.unicode.org/translation/grammatical-inflection">Grammatical Inflection</a>.</p><h2 id="3-number-format-patterns">3 <a name="Number_Format_Patterns" href="#Number_Format_Patterns">Number Format Patterns</a></h2><h3 id="31-number-patterns">3.1 <a name="Number_Patterns" href="#Number_Patterns">Number Patterns</a></h3><p>Number patterns affect how numbers are interpreted in a localized context. Here are some examples, based on the French locale. The "." shows where the decimal point should go. The "," shows where the thousands separator should go. A "0" indicates zero-padding: if the number is too short, a zero (in the locale's numeric set) will go there. A "#" indicates no padding: if the number is too short, nothing goes there. A "¤" shows where the currency sign will go. The following illustrates the effects of different patterns for the French locale, with the number "1234.567". Notice how the pattern characters ',' and '.' are replaced by the characters appropriate for the locale.</p><h5 id="number-pattern-examples"><a name="Number_Pattern_Examples" href="#Number_Pattern_Examples">Number Pattern Examples</a></h5><table>
<thead>
<tr>
<th>Pattern</th>
<th>Currency</th>
<th>Text</th>
</tr>
</thead>
<tbody><tr>
<td>#,##0.##</td>
<td><em>n/a</em></td>
<td>1 234,57</td>
</tr>
<tr>
<td>#,##0.###</td>
<td><em>n/a</em></td>
<td>1 234,567</td>
</tr>
<tr>
<td>###0.#####</td>
<td><em>n/a</em></td>
<td>1234,567</td>
</tr>
<tr>
<td>###0.0000#</td>
<td><em>n/a</em></td>
<td>1234,5670</td>
</tr>
<tr>
<td>00000.0000</td>
<td><em>n/a</em></td>
<td>01234,5670</td>
</tr>
<tr>
<td>#,##0.00 ¤</td>
<td>EUR</td>
<td>1 234,57 €</td>
</tr>
<tr>
<td></td>
<td>JPY</td>
<td>1 235 ¥JP</td>
</tr>
</tbody></table><p>The number of # placeholder characters before the decimal do not matter, since no limit is placed on the maximum number of digits. There should, however, be at least one zero someplace in the pattern. In currency formats, the number of digits after the decimal also do not matter, since the information in the supplemental data (see <em><a href="#Supplemental_Currency_Data">Supplemental Currency Data</a>)</em> is used to override the number of decimal places — and the rounding — according to the currency that is being formatted. That can be seen in the above chart, with the difference between Yen and Euro formatting.</p><p>To ensure correct layout, especially in currency patterns in which a a variety of symbols may be used, number patterns may contain (invisible) bidirectional text format characters such as LRM, RLM, and ALM.</p><p><em>When parsing using a pattern, a lenient parse should be used; see <a href="tr35.html#Lenient_Parsing">Lenient Parsing</a>.</em> As noted there, lenient parsing should ignore bidi format characters.</p><h3 id="32-special-pattern-characters">3.2 <a name="Special_Pattern_Characters" href="#Special_Pattern_Characters">Special Pattern Characters</a></h3><p>Many characters in a pattern are taken literally; they are matched during parsing and output unchanged during formatting. Special characters, on the other hand, stand for other characters, strings, or classes of characters. For example, the '#' character is replaced by a localized digit for the chosen numberSystem. Often the replacement character is the same as the pattern character; in the U.S. locale, the ',' grouping character is replaced by ','. However, the replacement is still happening, and if the symbols are modified, the grouping character changes. Some special characters affect the behavior of the formatter by their presence; for example, if the percent character is seen, then the value is multiplied by 100 before being displayed.</p><p>To insert a special character in a pattern as a literal, that is, without any special meaning, the character must be quoted. There are some exceptions to this which are noted below. The Localized Replacement column shows the replacement from <em>Section 2.3 <a href="#Number_Symbols">Number Symbols</a></em> or the numberSystem's digits: <em>italic</em> indicates a special function.</p><p>Invalid sequences of special characters (such as “¤¤¤¤¤¤” in current CLDR) should be handled for formatting and parsing as described in <a href="tr35.html#Invalid_Patterns">Handling Invalid Patterns</a>.</p><h5 id="number-pattern-character-definitions"><a name="Number_Pattern_Character_Definitions" href="#Number_Pattern_Character_Definitions">Number Pattern Character Definitions</a></h5><table>
<thead>
<tr>
<th align="left">Symbol</th>
<th align="left">Location</th>
<th align="left">Localized Replacement</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">Number</td>
<td align="left">digit</td>
<td align="left">Digit</td>
</tr>
<tr>
<td align="left">1-9</td>
<td align="left">Number</td>
<td align="left">digit</td>
<td align="left">'1' through '9' indicate rounding.</td>
</tr>
<tr>
<td align="left">@</td>
<td align="left">Number</td>
<td align="left">digit</td>
<td align="left">Significant digit</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">Number</td>
<td align="left">digit, <em>nothing</em></td>
<td align="left">Digit, omitting leading/trailing zeros</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">Number</td>
<td align="left">decimal, currencyDecimal</td>
<td align="left">Decimal separator or monetary decimal separator</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">Number</td>
<td align="left">minusSign, plusSign, approximatelySign</td>
<td align="left">Minus sign. <strong>Warning:</strong> the pattern '-'0.0 is not the same as the pattern -0.0. In the former case, the minus sign is a literal. In the latter case, it is a special symbol, which is replaced by the minusSymbol, and can also be replaced by the plusSymbol for a format like +12% as in Section 3.2.1 <a href="#Explicit_Plus">Explicit Plus Signs</a>.</td>
</tr>
<tr>
<td align="left">,</td>
<td align="left">Number</td>
<td align="left">group, currencyGroup</td>
<td align="left">Grouping separator. May occur in both the integer part and the fractional part. The position determines the grouping.</td>
</tr>
<tr>
<td align="left">E</td>
<td align="left">Number</td>
<td align="left">exponential, superscriptingExponent</td>
<td align="left">Separates mantissa and exponent in scientific notation. <em>Need not be quoted in prefix or suffix.</em></td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">Exponent or Number (for explicit plus)</td>
<td align="left">plusSign</td>
<td align="left">Prefix positive exponents with localized plus sign. Used for explicit plus for numbers as well, as described in Section 3.2.1 <a href="#Explicit_Plus">Explicit Plus Signs</a>. <em>Need not be quoted in prefix or suffix.</em></td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">Prefix or suffix</td>
<td align="left">percentSign</td>
<td align="left">Multiply by 100 and show as percentage</td>
</tr>
<tr>
<td align="left">‰ (U+2030)</td>
<td align="left">Prefix or suffix</td>
<td align="left">perMille</td>
<td align="left">Multiply by 1000 and show as per mille (aka “basis points”)</td>
</tr>
<tr>
<td align="left">;</td>
<td align="left">Subpattern boundary</td>
<td align="left"><em>syntax</em></td>
<td align="left">Separates positive and negative subpatterns. When there is no explicit negative subpattern, an implicit negative subpattern is formed from the positive pattern with a prefixed - (ASCII U+002D HYPHEN-MINUS).</td>
</tr>
<tr>
<td align="left">¤ (U+00A4)</td>
<td align="left">Prefix or suffix</td>
<td align="left"><em>currency symbol/name from currency specified in API</em></td>
<td align="left">Any sequence is replaced by the localized currency symbol for the currency being formatted, as in the table below. If present in a pattern, the monetary decimal separator and grouping separators (if available) are used instead of the numeric ones. If data is unavailable for a given sequence in a given locale, the display may fall back to ¤ or ¤¤. See also the formatting forcurrency display names, steps 2 and 4 in <a href="#Currencies">Currencies</a>. <table><tbody><tr><th>No.</th><th>Replacement / Example</th></tr><tr><td rowspan="2">¤</td><td>Standard currency symbol</td></tr><tr><td><em>C$12.00</em></td></tr><tr><td rowspan="2">¤¤</td><td>ISO currency symbol (constant)</td></tr><tr><td><em>CAD 12.00</em></td></tr><tr><td rowspan="2">¤¤¤</td><td>Appropriate currency display name for the currency,based on the plural rules in effect for the locale</td></tr><tr><td><em>5.00 Canadian dollars</em></td></tr><tr><td rowspan="2">¤¤¤¤¤</td><td>Narrow currency symbol. The same symbols may be used for multiple currencies. Thus the symbol may be ambiguous, and should only be where the context is clear.</td></tr><tr><td><em>$12.00</em></td></tr><tr><td><em>others</em></td><td><em>Invalid in current CLDR. Reserved for future specification</em></td></tr></tbody></table></td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">Prefix or suffix boundary</td>
<td align="left"><em>padding character specified in API</em></td>
<td align="left">Pad escape, precedes pad character</td>
</tr>
<tr>
<td align="left">'</td>
<td align="left">Prefix or suffix</td>
<td align="left"><em>syntax-only</em></td>
<td align="left">Used to quote special characters in a prefix or suffix, for example, <code>"'#'#"</code> formats 123 to <code>"#123"</code>. To create a single quote itself, use two in a row: <code>"# o''clock"</code>.</td>
</tr>
</tbody></table><p>A pattern contains a positive subpattern and may contain a negative subpattern, for example, "#,##0.00;(#,##0.00)". Each subpattern has a prefix, a numeric part, and a suffix. If there is no explicit negative subpattern, the implicit negative subpattern is the ASCII minus sign (-) prefixed to the positive subpattern. That is, "0.00" alone is equivalent to "0.00;-0.00". (The data in CLDR is normalized to remove an explicit negative subpattern where it would be identical to the implicit form.)</p><p>Note that if an negative subpattern is used as-is: a minus sign is <em>not</em> added, eg "0.00;0.00" ≠ "0.00;-0.00". Trailing semicolons are ignored, eg "0.00;" = "0.00". Whitespace is not ignored, including those around semicolons, so "0.00 ; -0.00" ≠ "0.00;-0.00".</p><p>If there is an explicit negative subpattern, it serves only to specify the negative prefix and suffix; the number of digits, minimal digits, and other characteristics are ignored in the negative subpattern. That means that "#,##0.0#;(#)" has precisely the same result as "#,##0.0#;(#,##0.0#)". However in the CLDR data, the format is normalized so that the other characteristics are preserved, just for readability.</p><blockquote>
<p><strong>Note:</strong> The thousands separator and decimal separator in patterns are always ASCII ',' and '.'. They are substituted by the code with the correct local values according to other fields in CLDR. The same is true of the - (ASCII minus sign) and other special characters listed above.</p>
</blockquote><p>A currency decimal pattern normally contains a currency symbol placeholder (¤, ¤¤, ¤¤¤, or ¤¤¤¤¤). The currency symbol placeholder may occur before the first digit, after the last digit symbol, or where the decimal symbol would otherwise be placed (for formats such as "12€50", as in "12€50 pour une omelette").</p><table>
<thead>
<tr>
<th>Placement</th>
<th>Examples</th>
</tr>
</thead>
<tbody><tr>
<td>Before</td>
<td>"¤#,##0.00" "¤ #,##0.00" "¤-#,##0.00" "¤ -#,##0.00" "-¤#,##0.00" "-¤ #,##0.00" …</td>
</tr>
<tr>
<td>After</td>
<td>"#,##0.00¤" "#,##0.00 ¤" "#,##0.00-¤" "#,##0.00- ¤" "#,##0.00¤-" "#,##0.00 ¤-" …</td>
</tr>
<tr>
<td>Decimal</td>
<td>"#,##0¤00"</td>
</tr>
</tbody></table><p>Below is a sample of patterns, special characters, and results:</p><h5 id="sample-patterns-and-results"><a name="Sample_Patterns_and_Results" href="#Sample_Patterns_and_Results">Sample Patterns and Results</a></h5><table><tbody>
<tr><th>explicit pattern:</th><td colspan="2">0.00;-0.00</td><td colspan="2">0.00;0.00-</td><td colspan="2">0.00+;0.00-</td></tr>
<tr><th>decimalSign:</th><td colspan="2">,</td><td colspan="2">,</td><td colspan="2">,</td></tr>
<tr><th>minusSign:</th><td colspan="2">∸</td><td colspan="2">∸</td><td colspan="2">∸</td></tr>
<tr><th>plusSign:</th><td colspan="2">∔</td><td colspan="2">∔</td><td colspan="2">∔</td></tr>
<tr><th>number:</th><td>3.1415</td><td>-3.1415</td><td>3.1415</td><td>-3.1415</td><td>3.1415</td><td>-3.1415</td></tr>
<tr><th>formatted:</th><td>3,14</td><td>∸3,14</td><td>3,14</td><td>3,14∸</td><td>3,14∔</td><td>3,14∸</td></tr>
</tbody></table><p><em>In the above table, ∸ = U+2238 DOT MINUS and ∔ = U+2214 DOT PLUS are used for illustration.</em></p><p>The prefixes, suffixes, and various symbols used for infinity, digits, thousands separators, decimal separators, and so on may be set to arbitrary values, and they will appear properly during formatting. <em>However, care must be taken that the symbols and strings do not conflict, or parsing will be unreliable.</em> For example, either the positive and negative prefixes or the suffixes must be distinct for any parser using this data to be able to distinguish positive from negative values. Another example is that the decimal separator and thousands separator should be distinct characters, or parsing will be impossible.</p><p>The <em>grouping separator</em> is a character that separates clusters of integer digits to make large numbers more legible. It is commonly used for thousands, but in some locales it separates ten-thousands. The <em>grouping size</em> is the number of digits between the grouping separators, such as 3 for "100,000,000" or 4 for "1 0000 0000". There are actually two different grouping sizes: One used for the least significant integer digits, the <em>primary grouping size</em>, and one used for all others, the <em>secondary grouping size</em>. In most locales these are the same, but sometimes they are different. For example, if the primary grouping interval is 3, and the secondary is 2, then this corresponds to the pattern "#,##,##0", and the number 123456789 is formatted as "12,34,56,789". If a pattern contains multiple grouping separators, the interval between the last one and the end of the integer defines the primary grouping size, and the interval between the last two defines the secondary grouping size. All others are ignored, so "#,##,###,####" == "###,###,####" == "##,#,###,####".</p><p>The grouping separator may also occur in the fractional part, such as in “#,##0.###,#”. This is most commonly done where the grouping separator character is a thin, non-breaking space (U+202F), such as “1.618 033 988 75”. See <a href="https://physics.nist.gov/cuu/Units/checklist.html">physics.nist.gov/cuu/Units/checklist.html</a>.</p><p>For consistency in the CLDR data, the following conventions are observed:</p><ul>
<li><p>All number patterns should be minimal: there should be no leading # marks except to specify the position of the grouping separators (for example, avoid  ##,##0.###).</p>
</li>
<li><p>All formats should have one 0 before the decimal point (for example, avoid #,###.##)</p>
</li>
<li><p>Decimal formats should have three hash marks in the fractional position (for example, #,##0.###).</p>
</li>
<li><p>Currency formats should have two zeros in the fractional position (for example, ¤ #,##0.00).</p>
<ul>
<li>The exact number of decimals is overridden with the decimal count in supplementary data or by API settings.</li>
</ul>
</li>
<li><p>The only time two thousands separators needs to be used is when the number of digits varies, such as for Hindi: #,##,##0.</p>
</li>
<li><p>The <strong>minimumGroupingDigits</strong> can be used to suppress groupings below a certain value. This is used for languages such as Polish, where one would only write the grouping separator for values above 9999. The minimumGroupingDigits contains the default for the locale.</p>
<ul>
<li><p>The attribute value is used by adding it to the grouping separator value. If the input number has fewer integer digits, the grouping separator is suppressed.</p>
</li>
<li><h5 id="examples-of-minimumgroupingdigits"><a name="Examples_of_minimumGroupingDigits" href="#Examples_of_minimumGroupingDigits">Examples of minimumGroupingDigits</a></h5>
<table>
<thead>
<tr>
<th align="right">minimum­GroupingDigits</th>
<th align="right">Pattern Grouping</th>
<th align="right">Input Number</th>
<th align="right">Formatted</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">1000</td>
<td align="right">1,000</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">10000</td>
<td align="right">10,000</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">1000</td>
<td align="right">1000</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">10000</td>
<td align="right">10,000</td>
</tr>
<tr>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">10000</td>
<td align="right">1,0000</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">4</td>
<td align="right">10000</td>
<td align="right">10000</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul><h4 id="321-explicit-plus-signs">3.2.1 <a name="Explicit_Plus" href="#Explicit_Plus">Explicit Plus Signs</a></h4><p>An explicit "plus" format can be formed, so as to show a visible + sign when formatting a non-negative number. The displayed plus sign can be an ASCII plus or another character, such as ＋ U+FF0B FULLWIDTH PLUS SIGN or ➕ U+2795 HEAVY PLUS SIGN; it is taken from whatever is set for plusSign in <em>Section 2.3 <a href="#Number_Symbols">Number Symbols</a></em>.</p><ol>
<li>Get the negative subpattern (explicit or implicit).</li>
<li>Replace any unquoted ASCII minus sign by an ASCII plus sign.</li>
<li>If there are any replacements, use that for the positive subpattern.</li>
</ol><p>For an example, see <a href="#Sample_Patterns_and_Results">Sample Patterns and Results</a>.</p><h3 id="33-formatting">3.3 <a name="Formatting" href="#Formatting">Formatting</a></h3><p>Formatting is guided by several parameters, all of which can be specified either using a pattern or using an external API designed for number formatting. The following description applies to formats that do not use <a href="#sci">scientific notation</a> or <a href="#sigdig">significant digits</a>.</p><ul>
<li>If the number of actual integer digits exceeds the <em>maximum integer digits</em>, then only the least significant digits are shown. For example, 1997 is formatted as "97" if the maximum integer digits is set to 2.</li>
<li>If the number of actual integer digits is less than the <em>minimum integer digits</em>, then leading zeros are added. For example, 1997 is formatted as "01997" if the minimum integer digits is set to 5.</li>
<li>If the number of actual fraction digits exceeds the <em>maximum fraction digits</em>, then half-even rounding it performed to the maximum fraction digits. For example, 0.125 is formatted as "0.12" if the maximum fraction digits is 2. This behavior can be changed by specifying a rounding increment and a rounding mode.</li>
<li>If the number of actual fraction digits is less than the <em>minimum fraction digits</em>, then trailing zeros are added. For example, 0.125 is formatted as "0.1250" if the minimum fraction digits is set to 4.</li>
<li>Trailing fractional zeros are not displayed if they occur <em>j</em> positions after the decimal, where <em>j</em> is less than the maximum fraction digits. For example, 0.10004 is formatted as "0.1" if the maximum fraction digits is four or less.</li>
</ul><p><strong>Special Values</strong></p><p><code>NaN</code> is represented as a single character, typically <code>(U+FFFD)</code> . This character is determined by the localized number symbols. This is the only value for which the prefixes and suffixes are not used.</p><p>Infinity is represented as a single character, typically ∞ <code>(U+221E)</code> , with the positive or negative prefixes and suffixes applied. The infinity character is determined by the localized number symbols.</p><h3 id="34-scientific-notation">3.4 <a name="sci" href="#sci">Scientific Notation</a></h3><p>Numbers in scientific notation are expressed as the product of a mantissa and a power of ten, for example, 1234 can be expressed as 1.234 x 103. The mantissa is typically in the half-open interval [1.0, 10.0) or sometimes [0.0, 1.0), but it need not be. In a pattern, the exponent character immediately followed by one or more digit characters indicates scientific notation. Example: "0.###E0" formats the number 1234 as "1.234E3".</p><ul>
<li>The number of digit characters after the exponent character gives the minimum exponent digit count. There is no maximum. Negative exponents are formatted using the localized minus sign, <em>not</em> the prefix and suffix from the pattern. This allows patterns such as "0.###E0 m/s". To prefix positive exponents with a localized plus sign, specify '+' between the exponent and the digits: "0.###E+0" will produce formats "1E+1", "1E+0", "1E-1", and so on. (In localized patterns, use the localized plus sign rather than '+'.)</li>
<li>The minimum number of integer digits is achieved by adjusting the exponent. Example: 0.00123 formatted with "00.###E0" yields "12.3E-4". This only happens if there is no maximum number of integer digits. If there is a maximum, then the minimum number of integer digits is fixed at one.</li>
<li>The maximum number of integer digits, if present, specifies the exponent grouping. The most common use of this is to generate <em>engineering notation</em>, in which the exponent is a multiple of three, for example, "##0.###E0". The number 12345 is formatted using "##0.####E0" as "12.345E3".</li>
<li>When using scientific notation, the formatter controls the digit counts using logic for significant digits. The maximum number of significant digits comes from the mantissa portion of the pattern: the string of #, 0, and period (".") characters immediately preceding the E. To get the maximum number of significant digits, use the following algorithm:  <ol>
<li>If the mantissa pattern contains a period:<ol>
<li>If the mantissa pattern contains at least one 0:<ul>
<li>  Return the number of 0s before the period added to the number of #s or 0s after the period</li>
</ul>
</li>
<li>Else:<ul>
<li>  Return 1 plus the number of #s after the period</li>
</ul>
</li>
</ol>
</li>
<li>Else:<ol>
<li>If the mantissa pattern contains at least one 0:<ul>
<li>  Return the number of 0s.</li>
</ul>
</li>
<li>Else:<ul>
<li>  Return positive infinity.</li>
</ul>
</li>
</ol>
</li>
</ol>
  Examples:  <ul>
<li>  0.##E0 means a max of 3 significant digits.</li>
<li>  #.##E0 also means a max of 3 significant digits.</li>
<li>  #.0#E0 means a max of 2 significant digits.</li>
<li>  0E0 means a max of 1 significant digit.</li>
<li>  #E0 means infinite precision.</li>
<li>  ###E0 means engineering notation with infinite precision.</li>
</ul>
</li>
<li>  Exponential patterns may not contain grouping separators.</li>
</ul><h3 id="35-significant-digits">3.5 <a name="sigdig" href="#sigdig">Significant Digits</a></h3><p>There are two ways of controlling how many digits are shows: (a) significant digits counts, or (b) integer and fraction digit counts. Integer and fraction digit counts are described above. When a formatter is using significant digits counts, it uses however many integer and fraction digits are required to display the specified number of significant digits. It may ignore min/max integer/fraction digits, or it may use them to the extent possible.</p><h5 id="significant-digits-examples"><a name="Significant_Digits_Examples" href="#Significant_Digits_Examples">Significant Digits Examples</a></h5><table>
<thead>
<tr>
<th align="left">Pattern</th>
<th align="left">Minimum significant digits</th>
<th align="left">Maximum significant digits</th>
<th align="left">Number</th>
<th align="left">Output</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@@@</code></td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">12345</td>
<td align="left"><code>12300</code></td>
</tr>
<tr>
<td align="left"><code>@@@</code></td>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">0.12345</td>
<td align="left"><code>0.123</code></td>
</tr>
<tr>
<td align="left"><code>@@##</code></td>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">3.14159</td>
<td align="left"><code>3.142</code></td>
</tr>
<tr>
<td align="left"><code>@@##</code></td>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">1.23004</td>
<td align="left"><code>1.23</code></td>
</tr>
</tbody></table><ul>
<li>In order to enable significant digits formatting, use a pattern containing the <code>'@'</code> pattern character. In order to disable significant digits formatting, use a pattern that does not contain the <code>'@'</code> pattern character.</li>
<li>Significant digit counts may be expressed using patterns that specify a minimum and maximum number of significant digits. These are indicated by the <code>'@'</code> and <code>'#'</code> characters. The minimum number of significant digits is the number of <code>'@'</code> characters. The maximum number of significant digits is the number of <code>'@'</code> characters plus the number of <code>'#'</code> characters following on the right. For example, the pattern <code>"@@@"</code> indicates exactly 3 significant digits. The pattern <code>"@##"</code> indicates from 1 to 3 significant digits. Trailing zero digits to the right of the decimal separator are suppressed after the minimum number of significant digits have been shown. For example, the pattern <code>"@##"</code> formats the number 0.1203 as <code>"0.12"</code>.</li>
<li>Implementations may forbid the use of significant digits in combination with min/max integer/fraction digits. In such a case, if a pattern uses significant digits, it may not contain a decimal separator, nor the <code>'0'</code> pattern character. Patterns such as <code>"@00"</code> or <code>"@.###"</code> would be disallowed.</li>
<li>Any number of <code>'#'</code> characters may be prepended to the left of the leftmost <code>'@'</code> character. These have no effect on the minimum and maximum significant digits counts, but may be used to position grouping separators. For example, <code>"#,#@#"</code> indicates a minimum of one significant digits, a maximum of two significant digits, and a grouping size of three.</li>
<li>The number of significant digits has no effect on parsing.</li>
<li>Significant digits may be used together with exponential notation. Such patterns are equivalent to a normal exponential pattern with a minimum and maximum integer digit count of one, a minimum fraction digit count of <code>Minimum Significant Digits - 1</code>, and a maximum fraction digit count of <code>Maximum Significant Digits - 1</code>. For example, the pattern <code>"@@###E0"</code> is equivalent to <code>"0.0###E0"</code>.</li>
</ul><h3 id="36-padding">3.6 <a name="Padding" href="#Padding">Padding</a></h3><p>Patterns support padding the result to a specific width. In a pattern the pad escape character, followed by a single pad character, causes padding to be parsed and formatted. The pad escape character is '*'. For example, <code>"$*x#,##0.00"</code> formats 123 to <code>"$xx123.00"</code> , and 1234 to <code>"$1,234.00"</code> .</p><ul>
<li>When padding is in effect, the width of the positive subpattern, including prefix and suffix, determines the format width. For example, in the pattern <code>"* #0 o''clock"</code>, the format width is 10.</li>
<li>Some parameters which usually do not matter have meaning when padding is used, because the pattern width is significant with padding. In the pattern "* ##,##,#,##0.##", the format width is 14. The initial characters "##,##," do not affect the grouping size or maximum integer digits, but they do affect the format width.</li>
<li>Padding may be inserted at one of four locations: before the prefix, after the prefix, before the suffix, or after the suffix. No padding can be specified in any other location. If there is no prefix, before the prefix and after the prefix are equivalent, likewise for the suffix.</li>
<li>When specified in a pattern, the code point immediately following the pad escape is the pad character. This may be any character, including a special pattern character. That is, the pad escape <em>escapes</em> the following character. If there is no character after the pad escape, then the pattern is illegal.</li>
</ul><h3 id="37-rounding">3.7 <a name="Rounding" href="#Rounding">Rounding</a></h3><p>Patterns support rounding to a specific increment. For example, 1230 rounded to the nearest 50 is 1250. Mathematically, rounding to specific increments is performed by dividing by the increment, rounding to an integer, then multiplying by the increment. To take a more bizarre example, 1.234 rounded to the nearest 0.65 is 1.3, as follows:</p><table><tbody>
<tr><th>Original:</th><td>1.234</td></tr>
<tr><th>Divide by increment (0.65):</th><td>1.89846…</td></tr>
<tr><th>Round:</th><td>2</td></tr>
<tr><th>Multiply by increment (0.65):</th><td>1.3</td></tr>
</tbody></table><p>To specify a rounding increment in a pattern, include the increment in the pattern itself. "#,#50" specifies a rounding increment of 50. "#,##0.05" specifies a rounding increment of 0.05.</p><ul>
<li>Rounding only affects the string produced by formatting. It does not affect parsing or change any numerical values.</li>
<li>An implementation may allow the specification of a <em>rounding mode</em> to determine how values are rounded. In the absence of such choices, the default is to round "half-even", as described in IEEE arithmetic. That is, it rounds towards the "nearest neighbor" unless both neighbors are equidistant, in which case, it rounds towards the even neighbor. Behaves as for round "half-up" if the digit to the left of the discarded fraction is odd; behaves as for round "half-down" if it's even. Note that this is the rounding mode that minimizes cumulative error when applied repeatedly over a sequence of calculations.</li>
<li>Some locales use rounding in their currency formats to reflect the smallest currency denomination.</li>
<li>In a pattern, digits '1' through '9' specify rounding, but otherwise behave identically to digit '0'.</li>
</ul><h3 id="38-quoting-rules">3.8 <a name="Quoting_Rules" href="#Quoting_Rules">Quoting Rules</a></h3><p>Single quotes, (<strong>'</strong>), enclose bits of the pattern that should be treated literally. Inside a quoted string, two single quotes ('') are replaced with a single one ('). For example: <code>'X '</code>#<code>' Q '</code> -&gt; <strong>X 1939 Q</strong> (Literal strings <code>shaded</code>.)</p><h2 id="4-currencies">4 <a name="Currencies" href="#Currencies">Currencies</a></h2><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currencies</span> (<span class="hljs-meta-keyword">alias</span> | (<span class="hljs-meta-keyword">default</span>?, <span class="hljs-meta-keyword">currency</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currency</span> (<span class="hljs-meta-keyword">alias</span> | (((<span class="hljs-meta-keyword">pattern</span>+, <span class="hljs-meta-keyword">displayName</span>*, <span class="hljs-meta-keyword">symbol</span>*) | (<span class="hljs-meta-keyword">displayName</span>+, <span class="hljs-meta-keyword">symbol</span>*, <span class="hljs-meta-keyword">pattern</span>*) | (<span class="hljs-meta-keyword">symbol</span>+, <span class="hljs-meta-keyword">pattern</span>*))?, <span class="hljs-meta-keyword">decimal</span>*, <span class="hljs-meta-keyword">group</span>*, <span class="hljs-meta-keyword">special</span>*)) &gt;</span>  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">symbol</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">symbol</span> <span class="hljs-meta-keyword">choice</span> ( <span class="hljs-meta-keyword">true</span> | <span class="hljs-meta-keyword">false</span> ) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span> <span class="hljs-comment">&lt;!-- deprecated --&gt;</span>
</code></pre><blockquote>
<p><strong>Note:</strong> The term "pattern" appears twice in the above. The first is for consistency with all other cases of pattern + displayName; the second is for backwards compatibility.</p>
</blockquote><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">currencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"USD"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Dollar<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">symbol</span>&gt;</span>$<span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">currency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">type</span> =<span class="hljs-string">"JPY"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Yen<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">symbol</span>&gt;</span>¥<span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">currency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"PTE"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Escudo<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">symbol</span>&gt;</span>$<span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">currency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">currencies</span>&gt;</span>
</code></pre><p>In formatting currencies, the currency number format is used with the appropriate symbol from <code>&lt;currencies&gt;</code>, according to the currency code. The <code>&lt;currencies&gt;</code> list can contain codes that are no longer in current use, such as PTE. The <code>choice</code> attribute has been deprecated.</p><p>The <code>count</code> attribute distinguishes the different plural forms, such as in the following:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">currencyFormats</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">unitPattern</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>{0} {1}<span class="hljs-tag">&lt;/<span class="hljs-name">unitPattern</span>&gt;</span>
    …
<span class="hljs-tag">&lt;<span class="hljs-name">currencies</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"ZWD"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span>&gt;</span>Zimbabwe Dollar<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>Zimbabwe dollar<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">displayName</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"other"</span>&gt;</span>Zimbabwe dollars<span class="hljs-tag">&lt;/<span class="hljs-name">displayName</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">symbol</span>&gt;</span>Z$<span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">currency</span>&gt;</span>
</code></pre><p>Note on displayNames:</p><ul>
<li>In general the region portion of the displayName should match the territory name, see <strong>Part 2</strong> <em>Section 1.2 <a href="tr35-general.html#locale_display_name_fields">Locale Display Name Fields</a></em>.</li>
<li>As a result, the English currency displayName in CLDR may not match the name in ISO 4217.</li>
</ul><p>To format a particular currency value "ZWD" for a particular numeric value <em>n</em> using the (long) display name:</p><ol>
<li>If the numeric value is exactly 0 or 1, first see if there is a count with a matching explicit number (0 or 1). If so, use that string (see <a href="#Explicit_0_1_rules">Explicit 0 and 1 rules</a>).</li>
<li>Otherwise, determine the <code>count</code> value that corresponds to <em>n</em> using the rules in <em><a href="#Language_Plural_Rules">Section 5 - Language Plural Rules</a></em></li>
<li>Next, get the currency unitPattern.<ol>
<li>Look for a <code>unitPattern</code> element that matches the <code>count</code> value, starting in the current locale and then following the locale fallback chain up to, but not including root.</li>
<li>If no matching <code>unitPattern</code> element was found in the previous step, then look for a <code>unitPattern</code> element that matches <code>count="other"</code>, starting in the current locale and then following the locale fallback chain up to root (which has a <code>unitPattern</code> element with <code>count="other"</code> for every unit type).</li>
<li>The resulting unitPattern element indicates the appropriate positioning of the numeric value and the currency display name.</li>
</ol>
</li>
<li>Next, get the <code>displayName</code> element for the currency.<ol>
<li>Look for a <code>displayName</code> element that matches the <code>count</code> value, starting in the current locale and then following the locale fallback chain up to, but not including root.</li>
<li>If no matching <code>displayName</code> element was found in the previous step, then look for a <code>displayName</code> element that matches <code>count="other"</code>, starting in the current locale and then following the locale fallback chain up to, but not including root.</li>
<li>If no matching <code>displayName</code> element was found in the previous step, then look for a <code>displayName</code> element that with no count, starting in the current locale and then following the locale fallback chain up to root.</li>
<li>If there is no <code>displayName</code> element, use the currency code itself (for example, "ZWD").</li>
</ol>
</li>
<li>Format the numeric value according to the locale. Use the locale’s <code>&lt;decimalFormats …&gt;</code> pattern, not the <code>&lt;currencyFormats&gt;</code> pattern that is used with the symbol (eg, Z$). As when formatting symbol currency values, reset the number of decimals according to the supplemental <code>&lt;currencyData&gt;</code> and use the currencyDecimal symbol if different from the decimal symbol.<ol>
<li>The number of decimals should be overridable in an API, so that clients can choose between “2 US dollars” and “2.00 US dollars”.</li>
</ol>
</li>
<li>Substitute the formatted numeric value for the {0} in the <code>unitPattern</code>, and the currency display name for the {1}.</li>
</ol><p>While for English this may seem overly complex, for some other languages different plural forms are used for different unit types; the plural forms for certain unit types may not use all of the plural-form tags defined for the language.</p><p>For example, if the the currency is ZWD and the number is 1234, then the latter maps to <code>count="other"</code> for English. The unit pattern for that is "{0} {1}", and the display name is "Zimbabwe dollars". The final formatted number is then "1,234 Zimbabwe dollars".</p><p>When the currency symbol is substituted into a pattern, there may be some further modifications, according to the following.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">currencySpacing</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">beforeCurrency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currencyMatch</span>&gt;</span>[:^S:]<span class="hljs-tag">&lt;/<span class="hljs-name">currencyMatch</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">surroundingMatch</span>&gt;</span>[:digit:]<span class="hljs-tag">&lt;/<span class="hljs-name">surroundingMatch</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">insertBetween</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">insertBetween</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">beforeCurrency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">afterCurrency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currencyMatch</span>&gt;</span>[:^S:]<span class="hljs-tag">&lt;/<span class="hljs-name">currencyMatch</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">surroundingMatch</span>&gt;</span>[:digit:]<span class="hljs-tag">&lt;/<span class="hljs-name">surroundingMatch</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">insertBetween</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">insertBetween</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">afterCurrency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">currencySpacing</span>&gt;</span>
</code></pre><p>This element controls whether additional characters are inserted on the boundary between the symbol and the pattern. For example, with the above <code>currencySpacing</code>, inserting the symbol "US$" into the pattern "#,##0.00¤" would result in an extra <em>no-break space</em> inserted before the symbol, for example, "#,##0.00 US$". The <code>beforeCurrency</code> element governs this case, since we are looking <em>before</em> the "¤" symbol. The <code>currencyMatch</code> is positive, since the "U" in "US$" is at the start of the currency symbol being substituted. The <code>surroundingMatch</code> is positive, since the character just before the "¤" will be a digit. Because these two conditions are true, the insertion is made.</p><p>Conversely, look at the pattern "¤#,##0.00" with the symbol "US$". In this case, there is no insertion; the result is simply "US$#,##0.00". The <code>afterCurrency</code> element governs this case, since we are looking <em>after</em> the "¤" symbol. The <code>surroundingMatch</code> is positive, since the character just after the "¤" will be a digit. However, the <code>currencyMatch</code> is <strong>not</strong> positive, since the "$" in "US$" is at the end of the currency symbol being substituted. So the insertion is not made.</p><p>For more information on the matching used in the <code>currencyMatch</code> and <code>surroundingMatch</code> elements, see the main document <em><a href="tr35.html#Unicode_Sets">Appendix E: Unicode Sets</a></em>.</p><p>Currencies can also contain optional grouping, decimal data, and pattern elements. This data is inherited from the <code>&lt;symbols&gt;</code> in the same locale data (if not present in the chain up to root), so only the <em>differing</em> data will be present. See the main document <em>Section 4.1 <a href="tr35.html#Multiple_Inheritance">Multiple Inheritance</a></em>.</p><blockquote>
<p><strong>Note:</strong> <em>Currency values should <strong>never</strong> be interchanged without a known currency code. You never want the number 3.5 interpreted as $3.50 by one user and €3.50 by another.</em> Locale data contains localization information for currencies, not a currency value for a country. A currency amount logically consists of a numeric value, plus an accompanying currency code (or equivalent). The currency code may be implicit in a protocol, such as where USD is implicit. But if the raw numeric value is transmitted without any context, then it has no definitive interpretation.</p>
</blockquote><p>Notice that the currency code is completely independent of the end-user's language or locale. For example, BGN is the code for Bulgarian Lev. A currency amount of &lt;BGN, 1.23456×10³&gt; would be localized for a Bulgarian user into "1 234,56 лв." (using Cyrillic letters). For an English user it would be localized into the string "BGN 1,234.56" The end-user's language is needed for doing this last localization step; but that language is completely orthogonal to the currency code needed in the data. After all, the same English user could be working with dozens of currencies. Notice also that the currency code is also independent of whether currency values are inter-converted, which requires more interesting financial processing: the rate of conversion may depend on a variety of factors.</p><p>Thus logically speaking, once a currency amount is entered into a system, it should be logically accompanied by a currency code in all processing. This currency code is independent of whatever the user's original locale was. Only in badly-designed software is the currency code (or equivalent) not present, so that the software has to "guess" at the currency code based on the user's locale.</p><blockquote>
<p><strong>Note:</strong> The number of decimal places <strong>and</strong> the rounding for each currency is not locale-specific data, and is not contained in the Locale Data Markup Language format. Those values override whatever is given in the currency numberFormat. For more information, see <em><a href="#Supplemental_Currency_Data">Supplemental Currency Data</a></em>.</p>
</blockquote><p>For background information on currency names, see [<a href="tr35.html#CurrencyInfo">CurrencyInfo</a>].</p><h3 id="41-supplemental-currency-data">4.1 <a name="Supplemental_Currency_Data" href="#Supplemental_Currency_Data">Supplemental Currency Data</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currencyData</span> ( <span class="hljs-meta-keyword">fractions</span>*, <span class="hljs-meta-keyword">region</span>+ ) &gt;</span>  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">fractions</span> ( <span class="hljs-meta-keyword">info</span>+ ) &gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">info</span> <span class="hljs-meta-keyword">EMPTY</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">info</span> <span class="hljs-meta-keyword">iso4217</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">info</span> <span class="hljs-meta-keyword">digits</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">info</span> <span class="hljs-meta-keyword">rounding</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">info</span> <span class="hljs-meta-keyword">cashDigits</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">info</span> <span class="hljs-meta-keyword">cashRounding</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">region</span> ( <span class="hljs-meta-keyword">currency</span>* ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">region</span> <span class="hljs-meta-keyword">iso3166</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">currency</span> ( <span class="hljs-meta-keyword">alternate</span>* ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">currency</span> <span class="hljs-meta-keyword">from</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">currency</span> <span class="hljs-meta-keyword">to</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">currency</span> <span class="hljs-meta-keyword">iso4217</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">currency</span> <span class="hljs-meta-keyword">tender</span> ( <span class="hljs-meta-keyword">true</span> | <span class="hljs-meta-keyword">false</span> ) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>
</code></pre><p>Each <code>currencyData</code> element contains one <code>fractions</code> element followed by one or more <code>region</code> elements. Here is an example for illustration.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">supplementalData</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currencyData</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">fractions</span>&gt;</span>
        …
        <span class="hljs-tag">&lt;<span class="hljs-name">info</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"CHF"</span> <span class="hljs-attr">digits</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">rounding</span>=<span class="hljs-string">"5"</span>/&gt;</span>
        …
        <span class="hljs-tag">&lt;<span class="hljs-name">info</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"ITL"</span> <span class="hljs-attr">digits</span>=<span class="hljs-string">"0"</span>/&gt;</span>
        …
        <span class="hljs-tag">&lt;/<span class="hljs-name">fractions</span>&gt;</span>
        …
        <span class="hljs-tag">&lt;<span class="hljs-name">region</span> <span class="hljs-attr">iso3166</span>=<span class="hljs-string">"IT"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"EUR"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"1999-01-01"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"ITL"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"1862-8-24"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"2002-02-28"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">region</span>&gt;</span>
        …
        <span class="hljs-tag">&lt;<span class="hljs-name">region</span> <span class="hljs-attr">iso3166</span>=<span class="hljs-string">"CS"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"EUR"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"2003-02-04"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"CSD"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"2002-05-15"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"YUM"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"1994-01-24"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"2002-05-15"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">region</span>&gt;</span>
        …
    <span class="hljs-tag">&lt;/<span class="hljs-name">currencyData</span>&gt;</span>
    …
<span class="hljs-tag">&lt;/<span class="hljs-name">supplementalData</span>&gt;</span>
</code></pre><p>The <code>fractions</code> element contains any number of <code>info</code> elements, with the following attributes:</p><ul>
<li><strong>iso4217:</strong> the ISO 4217 code for the currency in question. If a particular currency does not occur in the fractions list, then it is given the defaults listed for the next two attributes.</li>
<li><strong>digits:</strong> the minimum and maximum number of decimal digits normally formatted. The default is 2. For example, in the en_US locale with the default value of 2 digits, the value 1 USD would format as "$1.00", and the value 1.123 USD would format as → "$1.12".</li>
<li><strong>rounding:</strong> the rounding increment, in units of 10<sup>-digits</sup>. The default is 0, which means no rounding is to be done. Therefore, rounding=0 and rounding=1 have identical behavior. Thus with fraction digits of 2 and rounding increment of 5, numeric values are rounded to the nearest 0.05 units in formatting. With fraction digits of 0 and rounding increment of 50, numeric values are rounded to the nearest 50.</li>
<li><strong>cashDigits:</strong> the number of decimal digits to be used when formatting quantities used in cash transactions (as opposed to a quantity that would appear in a more formal setting, such as on a bank statement). If absent, the value of "digits" should be used as a default.</li>
<li><strong>cashRounding:</strong> the cash rounding increment, in units of 10-cashDigits. The default is 0, which means no rounding is to be done; and as with rounding, this has the same effect as cashRounding="1". This is the rounding increment to be used when formatting quantities used in cash transactions (as opposed to a quantity that would appear in a more formal setting, such as on a bank statement). If absent, the value of "rounding" should be used as a default.</li>
</ul><p>For example, the following line</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">info</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"CZK"</span> <span class="hljs-attr">digits</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">rounding</span>=<span class="hljs-string">"0"</span>/&gt;</span>
</code></pre><p>should cause the value 2.006 to be displayed as “2.01”, not “2.00”.</p><p>Each <code>region</code> element contains one attribute:</p><ul>
<li><strong>iso3166:</strong> the ISO 3166 code for the region in question. The special value <em>XXX</em> can be used to indicate that the region has no valid currency or that the circumstances are unknown (usually used in conjunction with <em>before</em>, as described below).</li>
</ul><p>And can have any number of <code>currency</code> elements, with the <code>ordered</code> subelements.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">region</span> <span class="hljs-attr">iso3166</span>=<span class="hljs-string">"IT"</span>&gt;</span> <span class="hljs-comment">&lt;!-- Italy --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"EUR"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"2002-01-01"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"ITL"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"2001-12-31"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">region</span>&gt;</span>
</code></pre><ul>
<li><strong>iso4217:</strong> the ISO 4217 code for the currency in question. Note that some additional codes that were in widespread usage are included, others such as GHP are not included because they were never used.</li>
<li><strong>from:</strong> the currency was valid from to the datetime indicated by the value. See the main document <em>Section 5.2.1 <a href="tr35.html#Date_Ranges">Dates and Date Ranges</a></em>.</li>
<li><strong>to:</strong> the currency was valid up to the datetime indicated by the value of <em>before</em>. See the main document <em>Section 5.2.1 <a href="tr35.html#Date_Ranges">Dates and Date Ranges</a></em>.</li>
<li><strong>tender:</strong> indicates whether or not the ISO currency code represents a currency that was or is legal tender in some country. The default is "true". Certain ISO codes represent things like financial instruments or precious metals, and do not represent normally interchanged currencies.</li>
</ul><p>That is, each <code>currency</code> element will list an interval in which it was valid. The <em>ordering</em> of the elements in the list tells us which was the primary currency during any period in time. Here is an example of such an overlap:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"CSD"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"2002-05-15"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"YUD"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"1994-01-24"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"2002-05-15"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">currency</span> <span class="hljs-attr">iso4217</span>=<span class="hljs-string">"YUN"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"1994-01-01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"1994-07-22"</span>/&gt;</span>
</code></pre><p>The <code>from</code> element is limited by the fact that ISO 4217 does not go very far back in time, so there may be no ISO code for the previous currency.</p><p>Currencies change relatively frequently. There are different types of changes:</p><ol>
<li>YU=&gt;CS (name change)</li>
<li>CS=&gt;RS+ME (split, different names)</li>
<li>SD=&gt;SD+SS (split, same name for one // South Sudan splits from Sudan)</li>
<li>DE+DD=&gt;DE (Union, reuses one name // East Germany unifies with Germany)</li>
</ol><p>The <a href="https://unstats.un.org/unsd/methodology/m49/">UN Information</a> is used to determine dates due to country changes.</p><p>When a code is no longer in use, it is terminated (see #1, #2, #4, #5)</p><blockquote>
<p>Example:</p>
<ul>
<li><code>&lt;currency iso4217="EUR" from="2003-02-04" to="2006-06-03"/&gt;</code></li>
</ul>
</blockquote><p>When codes split, each of the new codes inherits (see #2, #3) the previous data. However, some modifications can be made if it is clear that currencies were only in use in one of the parts.</p><p>When codes merge, the data is copied from the most populous part.</p><blockquote>
<p>Example. When CS split into RS and ME:</p>
<ul>
<li>RS &amp; ME copy the former CS, except that the line for EUR is dropped from RS</li>
<li>CS now terminates on Jun 3, 2006 (following the UN info)</li>
</ul>
</blockquote><h2 id="5-language-plural-rules">5 <a name="Language_Plural_Rules" href="#Language_Plural_Rules">Language Plural Rules</a></h2><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">plurals</span> (<span class="hljs-meta-keyword">pluralRules</span>*, <span class="hljs-meta-keyword">pluralRanges</span>*) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">plurals</span> <span class="hljs-meta-keyword">type</span> ( <span class="hljs-meta-keyword">ordinal</span> | <span class="hljs-meta-keyword">cardinal</span> ) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span> <span class="hljs-comment">&lt;!-- default is cardinal --&gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">pluralRules</span> (<span class="hljs-meta-keyword">pluralRule</span>*) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">pluralRules</span> <span class="hljs-meta-keyword">locales</span> <span class="hljs-meta-keyword">NMTOKENS</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">pluralRule</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">pluralRule</span> <span class="hljs-meta-keyword">count</span> (<span class="hljs-meta-keyword">zero</span> | <span class="hljs-meta-keyword">one</span> | <span class="hljs-meta-keyword">two</span> | <span class="hljs-meta-keyword">few</span> | <span class="hljs-meta-keyword">many</span> | <span class="hljs-meta-keyword">other</span>) <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>
</code></pre><p>The plural categories are used to format messages with numeric placeholders, expressed as decimal numbers. The fundamental rule for determining plural categories is the existence of minimal pairs: whenever two different numbers may require different versions of the same message, then the numbers have different plural categories.</p><p>This happens even if nouns are invariant; even if all English nouns were invariant (like “sheep”), English would still require 2 plural categories because of subject-verb agreement, and pronoun agreement. For example:</p><ol>
<li>1 sheep <strong>is</strong> here. Do you want to buy <strong>it</strong>?</li>
<li>2 sheep <strong>are</strong> here. Do you want to buy <strong>them</strong>?</li>
</ol><p>For more information, see <a href="http://cldr.unicode.org/index/cldr-spec/plural-rules#h.44ozdx564iez">Determining-Plural-Categories</a>.</p><p>English does not have a separate plural category for “zero”, because it does not require a different message for “0”. For example, the same message can be used below, with just the numeric placeholder changing.</p><ol>
<li>You have 3 friends online.</li>
<li>You have 0 friends online.</li>
</ol><p>However, across many languages it is commonly more natural to express "0" messages with a negative (“None of your friends are online.”) and "1" messages also with an alternate form “You have a friend online.”. Thus pluralized message APIs should also offer the ability to specify at least the 0 and 1 cases explicitly; developers can use that ability whenever these values might occur in a placeholder.</p><p>The CLDR plural rules are not expected to cover all cases. For example, strictly speaking, there could be more plural and ordinal forms for English. Formally, we have a different plural form where a change in digits forces a change in the rest of the sentence. There is an edge case in English because of the behavior of "a/an".</p><p>For example, in changing from 3 to 8:</p><ul>
<li>"a 3rd of a loaf" should result in "an 8th of a loaf", not "a 8th of a loaf"</li>
<li>"a 3 foot stick" should result in "an 8 foot stick", not "a 8 foot stick"</li>
</ul><p>So numbers of the following forms could have a special plural category and special ordinal category: 8(X), 11(X), 18(X), 8x(X), where x is 0..9 and the optional X is 00, 000, 00000, and so on.</p><p>On the other hand, the above constructions are relatively rare in messages constructed using numeric placeholders, so the disruption for implementations currently using CLDR plural categories wouldn't be worth the small gain.</p><p>This section defines the types of plural forms that exist in a language—namely, the cardinal and ordinal plural forms. Cardinal plural forms express units such as time, currency or distance, used in conjunction with a number expressed in decimal digits (i.e. "2", not "two", and not an indefinite number such as "some" or "many"). Ordinal plural forms denote the order of items in a set and are always integers. For example, English has two forms for cardinals:</p><ul>
<li>form "one": 1 day</li>
<li>form "other": 0 days, 2 days, 10 days, 0.3 days</li>
</ul><p>and four forms for ordinals:</p><ul>
<li>form "one": 1st floor, 21st floor, 101st floor</li>
<li>form "two": 2nd floor, 22nd floor, 102nd floor</li>
<li>form "few": 3rd floor, 23rd floor, 103rd floor</li>
<li>form "other": 4th floor, 11th floor, 96th floor</li>
</ul><p>Other languages may have additional forms or only one form for each type of plural. CLDR provides the following tags for designating the various plural forms of a language; for a given language, only the tags necessary for that language are defined, along with the specific numeric ranges covered by each tag (for example, the plural form "few" may be used for the numeric range 2–4 in one language and 3–9 in another):</p><ul>
<li>zero (see also plural case “0”, described in <a href="#Explicit_0_1_rules">Explicit 0 and 1 rules</a>)</li>
<li>one (see also plural case “1”, described in <a href="#Explicit_0_1_rules">Explicit 0 and 1 rules</a>)</li>
<li>two</li>
<li>few</li>
<li>many</li>
</ul><p>In addition, an "other" tag is always implicitly defined to cover the forms not explicitly designated by the tags defined for a language. This "other" tag is also used for languages that only have a single form (in which case no plural-form tags are explicitly defined for the language). For a more complex example, consider the cardinal rules for Russian and certain other languages:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluralRules</span> <span class="hljs-attr">locales</span>=<span class="hljs-string">"hr ru sr uk"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluralRules</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"one"</span>&gt;</span>n mod 10 is 1 and n mod 100 is not 11<span class="hljs-tag">&lt;/<span class="hljs-name">pluralRule</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluralRules</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"few"</span>&gt;</span>n mod 10 in 2..4 and n mod 100 not in 12..14<span class="hljs-tag">&lt;/<span class="hljs-name">pluralRule</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">pluralRules</span>&gt;</span>
</code></pre><p>These rules specify that Russian has a "one" form (for 1, 21, 31, 41, 51, …), a "few" form (for 2–4, 22–24, 32–34, …), and implicitly an "other" form (for everything else: 0, 5–20, 25–30, 35–40, …, decimals). Russian does not need additional separate forms for zero, two, or many, so these are not defined.</p><p>A source number represents the visual appearance of the digits of the result. In text, it can be represented by the EBNF for decimalValue. Note that the same double number can be represented by multiple source numbers. For example, "1.0" and "1.00" are different source numbers, but there is only one double number that they correspond to: 1.0d == 1.00d. As another example, 1e3d == 1000d, but the source numbers "1e3" and "1000" are different, and can have different plural categories. So the input to the plural rules carries more information than a computer double. The plural category for negative numbers is calculated according to the absolute value of the source number, and leading integer digits don't have any effect on the plural category calculation. (This may change in the future, if we find languages that have different behavior.)</p><p>Plural categories may also differ according to the visible decimals. For example, here are some of the behaviors exhibited by different languages:</p><table>
<thead>
<tr>
<th>Behavior</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>Base</td>
<td>The fractions are ignored; the category is the same as the category of the integer.</td>
<td>1.13 has the same plural category as 1.</td>
</tr>
<tr>
<td>Separate</td>
<td>All fractions by value are in one category (typically ‘other’ = ‘plural’).</td>
<td>1.01 gets the same class as 9; <br> 1.00 gets the same category as 1.</td>
</tr>
<tr>
<td>Visible</td>
<td>All visible fractions are in one category (typically ‘other’ = ‘plural).</td>
<td>1.00, 1.01, 3.5 all get the same category.</td>
</tr>
<tr>
<td>Digits</td>
<td>The visible fraction determines the category.</td>
<td>1.13 gets the same class as 13.</td>
</tr>
</tbody></table><p>There are also variants of the above: for example, short fractions may have the Digits behavior, but longer fractions may just look at the final digit of the fraction.</p><h4 id="explicit-0-and-1-rules"><a name="Explicit_0_1_rules" href="#Explicit_0_1_rules">Explicit 0 and 1 rules</a></h4><p>Some types of CLDR data (such as <a href="tr35-general.html#Unit_Elements">unitPatterns</a> and <a href="#Currencies">currency displayNames</a>) allow specification of plural rules for explicit cases “0” and “1”, in addition to the language-specific plural cases specified above: “zero”, “one”, “two” ... “other”. For the language-specific plural rules:</p><ul>
<li>The rules depend on language; for a given language, only a subset of the cases may be defined. For example, English only defines “one” and “other”, cases like “two” and “few” cannot be used in plurals for English CLDR items.</li>
<li>Each plural case may cover multiple numeric values, and may depend on the formatting of those values. For example, in French the “one” case covers 0.0 through 1.99.</li>
<li>The “one” case, if defined, includes at least some formatted forms of the numeric value 1; the “zero” case, if defined, includes at least some formatted forms of the numeric value 0.</li>
</ul><p>By contrast, for the explicit cases “0” and “1”:</p><ul>
<li>The explicit “0” and “1” cases are not defined by language-specific rules, and are available in any language for the CLDR data items that accept them.</li>
<li>The explicit “0” and “1” cases apply to the exact numeric values 0 and 1 respectively. These cases are typically used for plurals of items that do not have fractional value, like books or files.</li>
<li>The explicit “0” and “1” cases have precedence over the “zero” and “one” cases. For example, if for a particular element CLDR data includes values for both the “1” and “one” cases, then the “1” value is used for numeric values of exactly 1, while the “one” value is used for any other formatted numeric values matching the “one” plural rule for the language.</li>
</ul><p>Usage example: In English (which only defines language-specific rules for “one” and “other”) this can be used to have special behavior for 0:</p><ul>
<li>count=“0”: no books</li>
<li>count=“one”: {0} book, e.g. “1 book”</li>
<li>count=“other”: {0} books, e.g. “3 books”</li>
</ul><h3 id="51-plural-rules-syntax">5.1 <a name="Plural_rules_syntax" href="#Plural_rules_syntax">Plural rules syntax</a></h3><p>The xml value for each pluralRule is a <em>condition</em> with a boolean result that specifies whether that rule (i.e. that plural form) applies to a given numeric value <em>n</em>, where n can be expressed as a decimal fraction or with compact decimal formatting, denoted by a special notation in the syntax, e.g., “1.2c6” for “1.2M”. Clients of CLDR may express all the rules for a locale using the following syntax:</p><pre><code>rules         = rule (';' rule)*
rule          = keyword ':' condition samples
              | 'other' ':' samples
keyword       = [a-z]+
keyword       = [a-z]+
</code></pre><p>In CLDR, the keyword is the attribute value of 'count'. Those values in CLDR are currently limited to just what is in the DTD, but clients may support other values.</p><p>The conditions themselves have the following syntax.</p><pre><code>condition       = and_condition ('or' and_condition)*
samples         = ('@integer' sampleList)?
                  ('@decimal' sampleList)?                
and_condition   = relation ('and' relation)*
relation        = is_relation | in_relation | within_relation 
is_relation     = expr 'is' ('not')? value
in_relation     = expr (('not')? 'in' | '=' | '!=') range_list
within_relation = expr ('not')? 'within' range_list
expr            = operand (('mod' | '%') value)?
operand         = 'n' | 'i' | 'f' | 't' | 'v' | 'w' | 'c' | 'e'
range_list      = (range | value) (',' range_list)*
range           = value'..'value
value           = digit+
sampleList      = sampleRange (',' sampleRange)* (',' ('…'|'...'))?
sampleRange     = sampleValue ('~' sampleValue)?
sampleValue     = value ('.' digit+)? ([ce] digitPos digit+)?
digit           = [0-9]
digitPos        = [1-9]
</code></pre><ul>
<li>Whitespace (defined as Unicode <a href="https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5Cp%7BPattern_White_Space%7D">Pattern_White_Space</a>) can occur between or around any of the above tokens, with the exception of the tokens in value, digit, and decimalValue.</li>
<li>In the syntax, <strong>and</strong> binds more tightly than <strong>or</strong>. So <strong>X or Y and Z</strong> is interpreted as <strong>(X or (Y and Z))</strong>.</li>
<li>Each plural rule must be written to be self-contained, and not depend on the ordering. Thus rules must be mutually exclusive; for a given numeric value, only one rule can apply (i.e., the condition can only be true for one of the pluralRule elements. Each keyword can have at most one condition. The 'other' keyword must have an empty condition: it is only present for samples.</li>
<li>The samples should be included, since they are used by client software for samples and determining whether the keyword has finite values or not.</li>
<li>The 'other' keyword must have no condition, and all other keywords must have a condition.</li>
</ul><h4 id="511-operands">5.1.1 <a name="Operands" href="#Operands">Operands</a></h4><p>The operands correspond to features of the source number, and have the following meanings.</p><h5 id="plural-operand-meanings"><a name="Plural_Operand_Meanings" href="#Plural_Operand_Meanings">Plural Operand Meanings</a></h5><table>
<thead>
<tr>
<th>Symbol</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>absolute value of the source number.</td>
</tr>
<tr>
<td>i</td>
<td>integer digits of n.</td>
</tr>
<tr>
<td>v</td>
<td>number of visible fraction digits in n, <em>with</em> trailing zeros.*</td>
</tr>
<tr>
<td>w</td>
<td>number of visible fraction digits in n, <em>without</em> trailing zeros.*</td>
</tr>
<tr>
<td>f</td>
<td>visible fraction digits in n, <em>with</em> trailing zeros.*</td>
</tr>
<tr>
<td>t</td>
<td>visible fraction digits in n, <em>without</em> trailing zeros.*</td>
</tr>
<tr>
<td>c</td>
<td>compact decimal exponent value: exponent of the power of 10 used in compact decimal formatting.</td>
</tr>
<tr>
<td>e</td>
<td>currently, synonym for ‘c’. however, may be redefined in the future.</td>
</tr>
</tbody></table><p>* If there is a compact decimal exponent value (‘c’), then the f, t, v, and w values are computed <em>after</em> shifting the decimal point in the original by the ‘c’ value. So for 1.2c3, the f, t, v, and w values are the same as those of 1200:  i=1200 and f=0. Similarly, for 1.2005c3 has i=1200 and f=5 (corresponding to 1200.5).</p><h5 id="plural-operand-examples"><a name="Plural_Operand_Examples" href="#Plural_Operand_Examples">Plural Operand Examples</a></h5><table>
<thead>
<tr>
<th align="right">source</th>
<th align="right">n</th>
<th align="right">i</th>
<th align="right">v</th>
<th align="right">w</th>
<th align="right">f</th>
<th align="right">t</th>
<th align="right">e</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.0</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.00</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.3</td>
<td align="right">1.3</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.30</td>
<td align="right">1.3</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">30</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.03</td>
<td align="right">1.03</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.230</td>
<td align="right">1.23</td>
<td align="right">1</td>
<td align="right">3</td>
<td align="right">2</td>
<td align="right">230</td>
<td align="right">23</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1200000</td>
<td align="right">1200000</td>
<td align="right">1200000</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.2c6</td>
<td align="right">1200000</td>
<td align="right">1200000</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">6</td>
</tr>
<tr>
<td align="right">123c6</td>
<td align="right">123000000</td>
<td align="right">123000000</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">6</td>
</tr>
<tr>
<td align="right">123c5</td>
<td align="right">12300000</td>
<td align="right">12300000</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">5</td>
</tr>
<tr>
<td align="right">1200.50</td>
<td align="right">1200.5</td>
<td align="right">1200</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">50</td>
<td align="right">5</td>
<td align="right">0</td>
</tr>
<tr>
<td align="right">1.20050c3</td>
<td align="right">1200.5</td>
<td align="right">1200</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">50</td>
<td align="right">5</td>
<td align="right">3</td>
</tr>
</tbody></table><h4 id="512-relations">5.1.2 <a name="Relations" href="#Relations">Relations</a></h4><p>The positive relations are of the format <strong>x = y</strong> and <strong>x = y mod z</strong>. The <strong>y</strong> value can be a comma-separated list, such as <strong>n = 3, 5, 7..15</strong>, and is treated as if each relation were expanded into an OR statement. The range value <strong>a..b</strong> is equivalent to listing all the _<strong>integers</strong>_ between <strong>a</strong> and <strong>b</strong>, inclusive. When <strong>!=</strong> is used, it means the entire relation is negated.</p><h5 id="relations-examples"><a name="Relations_Examples" href="#Relations_Examples">Relations Examples</a></h5><table>
<thead>
<tr>
<th>Expression</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>x = 2..4, 15</td>
<td>x = 2 OR x = 3 OR x = 4 OR x = 15</td>
</tr>
<tr>
<td>x != 2..4, 15</td>
<td>NOT (x = 2 OR x = 3 OR x = 4 OR x = 15)</td>
</tr>
</tbody></table><table>
<thead>
<tr>
<th>Expression</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>3.5 = 2..4, 15</td>
<td>false</td>
</tr>
<tr>
<td>3.5 != 2..4, 15</td>
<td>true</td>
</tr>
<tr>
<td>3 = 2..4, 15</td>
<td>true</td>
</tr>
<tr>
<td>3 != 2..4, 15</td>
<td>false</td>
</tr>
</tbody></table><blockquote>
<p>The old keywords 'mod', 'in', 'is', and 'within' are present only for backwards compatibility. The preferred form is to use '%' for modulo, and '=' or '!=' for the relations, with the operand 'i' instead of within. (The difference between <strong>in</strong> and <strong>within</strong> is that <strong>in</strong> only includes integers in the specified range, while <strong>within</strong> includes all values.)</p>
</blockquote><p>The modulus (% or <strong>mod</strong>) is a remainder operation as defined in Java; for example, where <strong>n</strong> = 4.3 the result of <strong>n mod 3</strong> is 1.3.</p><p>The values of relations are defined according to the operand as follows. Importantly, the results may depend on the visible decimals in the source, including trailing zeros, and the compact decimal exponent.</p><ol>
<li>Let the base value BV be computed from absolute value of the original source number according to the operand.</li>
<li>Let R be false when the comparison contains ‘not’.</li>
<li>Let R be !R if the comparison contains ‘within’ and the source number is not an integer.</li>
<li>If there is a module value MV, let BV be BV - floor(BV/MV).</li>
<li>Let CR be the list of comparison ranges, normalized that overlapping ranges are merged. Single values in the rule are represented by a range with identical &lt;starti, endi&gt; values.</li>
<li>Iterate through CR:<ul>
<li>if starti ≤ BV ≤ endi then return R.</li>
</ul>
</li>
<li>Otherwise return !R.</li>
</ol><h5 id="plural-rules-examples"><a name="Plural_Rules_Examples" href="#Plural_Rules_Examples">Plural Rules Examples</a></h5><table>
<thead>
<tr>
<th>Rules</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td>one: n = 1 <br> few: n = 2..4</td>
<td>This defines two rules, for 'one' and 'few'. The condition for 'one' is "n = 1" which means that the number must be equal to 1 for this condition to pass. The condition for 'few' is "n = 2..4" which means that the number must be between 2 and 4 inclusive for this condition to pass. All other numbers are assigned the keyword 'other' by the default rule.</td>
</tr>
<tr>
<td>zero: n = 0 or n != 1 and n mod 100 = 1..19 <br> one: n = 1</td>
<td>Each rule must not overlap with other rules. Also note that a modulus is applied to n in the last rule, thus its condition holds for 119, 219, 319…</td>
</tr>
<tr>
<td>one: n = 1 <br> few: n mod 10 = 2..4 and n mod 100 != 12..14</td>
<td>This illustrates conjunction and negation. The condition for 'few' has two parts, both of which must be met: "n mod 10 = 2..4" and "n mod 100 != 12..14". The first part applies a modulus to n before the test as in the previous example. The second part applies a different modulus and also uses negation, thus it matches all numbers <em>not</em> in 12, 13, 14, 112, 113, 114, 212, 213, 214…</td>
</tr>
</tbody></table><h4 id="513-samples">5.1.3 <a name="Samples" href="#Samples">Samples</a></h4><p>Samples are provided if sample indicator (@integer or @decimal) is present on any rule. (CLDR always provides samples.)</p><p>Where samples are provided, the absence of one of the sample indicators indicates that no numeric values can satisify that rule. For example, the rule "i = 1 and v = 0" can only have integer samples, so @decimal must not occur. The @integer samples have no visible fraction digits, while @decimal samples have visible fraction digits; both can have compact decimal exponent values (if the 'e' operand occurs).</p><p>The sampleRanges have a special notation: <strong>start</strong>~<strong>end</strong>. The <strong>start</strong> and <strong>end</strong> values must have the same number of decimal digits, and the same compact decimal exponent values (or neither have compact decimal exponent values). The range encompasses all and only values those value <strong>v</strong> where <strong>start ≤ v ≤ end</strong>, and where <strong>v</strong> has the same number of decimal places as <strong>start</strong> and <strong>end</strong>, and the same compact decimal exponent values.</p><p>Samples must indicate whether they are infinite or not. The '…' marker must be present if and only infinitely many values (integer or decimal) can satisfy the rule. If a set is not infinite, it must list all the possible values.</p><h5 id="plural-samples-examples"><a name="Plural_Samples_Examples" href="#Plural_Samples_Examples">Plural Samples Examples</a></h5><table>
<thead>
<tr>
<th>Rules</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td>@integer 1, 3~5</td>
<td>1, 3, 4, 5.</td>
</tr>
<tr>
<td>@integer 3~5, 103~105, …</td>
<td>Infinite set: 3, 4, 5, 103, 104, 105, …</td>
</tr>
<tr>
<td>@decimal 1.3~1.5, 1.03~1.05, …</td>
<td>Infinite set: 1.3, 1.4, 1.5, 1.03, 1.04, 1.05, …</td>
</tr>
</tbody></table><p>In determining whether a set of samples is infinite, leading zero integer digits and trailing zero decimals are not significant. Thus "i = 1000 and f = 0" is satisfied by 01000, 1000, 1000.0, 1000.00, 1000.000, 01c3 etc. but is still considered finite.</p><h4 id="514-using-cardinals">5.1.4 <a name="Using_cardinals" href="#Using_cardinals">Using Cardinals</a></h4><p>Elements such as <code>&lt;currencyFormats&gt;</code>, <code>&lt;currency&gt;</code> and <code>&lt;unit&gt;</code> provide selection among subelements designating various localized cardinal plural forms by tagging each of the relevant subelements with a different count value, or with no count value in some cases. Note that the plural forms for a specific currencyFormat, unit type, or currency type may not use all of the different plural-form tags defined for the language. To format a currency or unit type for a particular numeric value, determine the count value according to the plural rules for the language, then select the appropriate display form for the currency format, currency type or unit type using the rules in those sections:</p><ul>
<li>2.3 <a href="#Number_Symbols">Number Symbols</a> (for <code>currencyFormat</code>s elements)</li>
<li>Section 4 <a href="#Currencies">Currencies</a> (for <code>currency</code> elements)</li>
<li>The main document section 5.11 <a href="tr35.html#Unit_Elements">Unit Elements</a></li>
</ul><h3 id="52-plural-ranges">5.2 <a name="Plural_Ranges" href="#Plural_Ranges">Plural Ranges</a></h3><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">pluralRanges</span> (<span class="hljs-meta-keyword">pluralRange</span>*) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">pluralRanges</span> <span class="hljs-meta-keyword">locales</span> <span class="hljs-meta-keyword">NMTOKENS</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">pluralRange</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">pluralRange</span> <span class="hljs-meta-keyword">start</span> (<span class="hljs-meta-keyword">zero</span>|<span class="hljs-meta-keyword">one</span>|<span class="hljs-meta-keyword">two</span>|<span class="hljs-meta-keyword">few</span>|<span class="hljs-meta-keyword">many</span>|<span class="hljs-meta-keyword">other</span>) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">pluralRange</span> <span class="hljs-meta-keyword">end</span> (<span class="hljs-meta-keyword">zero</span>|<span class="hljs-meta-keyword">one</span>|<span class="hljs-meta-keyword">two</span>|<span class="hljs-meta-keyword">few</span>|<span class="hljs-meta-keyword">many</span>|<span class="hljs-meta-keyword">other</span>) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">pluralRange</span> <span class="hljs-meta-keyword">result</span> (<span class="hljs-meta-keyword">zero</span>|<span class="hljs-meta-keyword">one</span>|<span class="hljs-meta-keyword">two</span>|<span class="hljs-meta-keyword">few</span>|<span class="hljs-meta-keyword">many</span>|<span class="hljs-meta-keyword">other</span>) <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>
</code></pre><p>Often ranges of numbers are presented to users, such as in “Length: 3.2–4.5 centimeters”. This means any length from 3.2 cm to 4.5 cm, inclusive. However, different languages have different conventions for the pluralization given to a range: should it be “0–1 centimeter” or “0–1 centimeters”? This becomes much more complicated for languages that have many different plural forms, such as Russian or Arabic.</p><p>The <code>pluralRanges</code> element provides information allowing an implementation to derive the plural category of a range from the plural categories of the <code>start</code> and <code>end</code> values. If there is no value for a <em>&lt;<code>start</code>,<code>end</code>&gt;</em> pair, the default result is <code>end</code>. However, where that result has been verified for a given language, it is included in the CLDR data.</p><p>The data has been gathered presuming that in any usage, the start value is strictly less than the end value, and that no values are negative. Results for any cases that do not meet these criteria are undefined.</p><h2 id="6-rule-based-number-formatting">6 <a name="Rule-Based_Number_Formatting" href="#Rule-Based_Number_Formatting">Rule-Based Number Formatting</a></h2><pre><code class="language-xml"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">rbnf</span> ( <span class="hljs-meta-keyword">alias</span> | <span class="hljs-meta-keyword">rulesetGrouping</span>*) &gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">rulesetGrouping</span> ( <span class="hljs-meta-keyword">alias</span> | <span class="hljs-meta-keyword">ruleset</span>*) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">rulesetGrouping</span> <span class="hljs-meta-keyword">type</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span>&gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">ruleset</span> ( <span class="hljs-meta-keyword">alias</span> | <span class="hljs-meta-keyword">rbnfrule</span>*) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">ruleset</span> <span class="hljs-meta-keyword">type</span> <span class="hljs-meta-keyword">NMTOKEN</span> <span class="hljs-meta-keyword">#REQUIRED</span>&gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">ruleset</span> <span class="hljs-meta-keyword">access</span> ( <span class="hljs-meta-keyword">public</span> | <span class="hljs-meta-keyword">private</span> ) <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
  
<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">rbnfrule</span> ( <span class="hljs-meta-keyword">#PCDATA</span> ) &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">rbnfrule</span> <span class="hljs-meta-keyword">value</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#REQUIRED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">rbnfrule</span> <span class="hljs-meta-keyword">radix</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>  
<span class="hljs-meta">&lt;!ATTLIST <span class="hljs-meta-keyword">rbnfrule</span> <span class="hljs-meta-keyword">decexp</span> <span class="hljs-meta-keyword">CDATA</span> <span class="hljs-meta-keyword">#IMPLIED</span> &gt;</span>
</code></pre><p>The rule-based number format (RBNF) encapsulates a set of rules for mapping binary numbers to and from a readable representation. They are typically used for spelling out numbers, but can also be used for other number systems like roman numerals, Chinese numerals, or for ordinal numbers (1st, 2nd, 3rd,…).</p><p>Where, however, the CLDR plurals or ordinals can be used, their usage is recommended in preference to the RBNF data. First, the RBNF data is not completely fleshed out over all languages that otherwise have modern coverage. Secondly, the alternate forms are neither complete, nor useful without additional information. For example, for German there is spellout-cardinal-masculine, and spellout-cardinal-feminine. But a complete solution would have all genders (masculine/feminine/neuter), all cases (nominative, accusative, dative, genitive), plus context (with strong or weak determiner or none). Moreover, even for the alternate forms that do exist, CLDR does not supply any data for when to use one vs another (eg, when to use spellout-cardinal-masculine vs spellout-cardinal-feminine). So these data are inappropriate for general purpose software.</p><p>There are 4 common spellout rules. Some languages may provide more than these 4 types:  </p><ul>
<li><strong>numbering:</strong> This is the default used when there is no context for the number. For many languages, this may also be used for enumeration of objects, like used when pronouncing "table number one" and "table number two". It can also be used for pronouncing a math equation, like "2 - 3 = -1".</li>
<li><strong>numbering-year:</strong> This is used for cases where years are pronounced or written a certain way. An example in English is the year 1999, which comes out as "nineteen ninety-nine" instead of the numbering value "one thousand nine hundred ninety-nine". The rules for this type have undefined behavior for non-integer numbers, and values less than 1.</li>
<li><strong>cardinal:</strong> This is used when providing the quantity of the number of objects. For many languages, there may not be a default cardinal type. Many languages require the notion of the gender and other grammatical properties so that the number and the objects being referenced are in grammatical agreement. An example of its usage is "one e-mail", "two people" or "three kilometers". Some languages may not have dedicated words for 0 or negative numbers for cardinals. In those cases, the words from the numbering type can be reused.</li>
<li><strong>ordinal:</strong> This is used when providing the order of the number of objects. For many languages, there may not be a default ordinal type. Many languages also require the notion of the gender for ordinal so that the ordinal number and the objects being referenced are in grammatical agreement. An example of its usage is "first place", "second e-mail" or "third house on the right". The rules for this type have undefined behavior for non-integer numbers, and values less than 1.</li>
</ul><p>In addition to the spellout rules, there are also a numbering system rules. Even though they may be derived from a specific culture, they are typically not translated and the rules are in <strong>root</strong>. An example of these rules are the Roman numerals where the value 8 comes out as VIII.  </p><p>With regards to the number range supported for all these number types, the largest possible number range tries to be supported, but some languages may not have words for large numbers. For example, the old Roman numbering system can't support the value 5000 and beyond. For those unsupported cases, the default number format from CLDR is used.  </p><p>Any rules marked as <strong>private</strong> should never be referenced externally. Frequently they only support a subrange of numbers that are used in the public rules.  </p><p>The syntax used in the CLDR representation of rules is intended to be simply a transcription of ICU based RBNF rules into an XML compatible syntax. The rules are fairly sophisticated; for details see <em>Rule-Based Number Formatter</em> [<a href="tr35.html#RBNF">RBNF</a>].</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ruleSetGrouping</span>&gt;</span>
</code></pre><p>Used to group rules into functional sets for use with ICU. Currently, the valid types of rule set groupings are "SpelloutRules", "OrdinalRules", and "NumberingSystemRules".</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ruleset</span>&gt;</span>
</code></pre><p>This element denotes a specific rule set to the number formatter. The ruleset is assumed to be a public ruleset unless the attribute type="private" is specified.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>
</code></pre><p>Contains the actual formatting rule for a particular number or sequence of numbers. The <code>value</code> attribute is used to indicate the starting number to which the rule applies. The actual text of the rule is identical to the ICU syntax, with the exception that Unicode left and right arrow characters are used to replace &lt; and &gt; in the rule text, since &lt; and &gt; are reserved characters in XML. The <code>radix</code> attribute is used to indicate an alternate radix to be used in calculating the prefix and postfix values for number formatting. Alternate radix values are typically used for formatting year numbers in formal documents, such as "nineteen hundred seventy-six" instead of "one thousand nine hundred seventy-six".</p><h2 id="7-parsing-numbers">7 <a name="Parsing_Numbers" href="#Parsing_Numbers">Parsing Numbers</a></h2><p>The following elements are relevant to determining the value of a parsed number:</p><ul>
<li>A possible prefix or suffix, indicating sign</li>
<li>A possible currency symbol or code</li>
<li>Decimal digits</li>
<li>A possible decimal separator</li>
<li>A possible exponent</li>
<li>A possible percent or per mille character</li>
</ul><p>Other characters should either be ignored, or indicate the end of input, depending on the application. The key point is to disambiguate the sets of characters that might serve in more than one position, based on context. For example, a period might be either the decimal separator, or part of a currency symbol (for example, "NA f."). Similarly, an "E" could be an exponent indicator, or a currency symbol (the Swaziland Lilangeni uses "E" in the "en" locale). An apostrophe might be the decimal separator, or might be the grouping separator.</p><p>Here is a set of heuristic rules that may be helpful:</p><ul>
<li>Any character with the decimal digit property is unambiguous and should be accepted.<strong>Note:</strong> In some environments, applications may independently wish to restrict the decimal digit set to prevent security problems. See [<a href="https://www.unicode.org/reports/tr41/#UTR36">UTR36</a>].</li>
<li>The exponent character can only be interpreted as such if it occurs after at least one digit, and if it is followed by at least one digit, with only an optional sign in between. A regular expression may be helpful here.</li>
<li>For the sign, decimal separator, percent, and per mille, use a set of all possible characters that can serve those functions. For example, the decimal separator set could include all of [.,']. (The actual set of characters can be derived from the number symbols in the By-Type charts [<a href="tr35.html#ByType">ByType</a>], which list all of the values in CLDR.) To disambiguate, the decimal separator for the locale must be removed from the "ignore" set, and the grouping separator for the locale must be removed from the decimal separator set. The same principle applies to all sets and symbols: any symbol must appear in at most one set.</li>
<li>Since there are a wide variety of currency symbols and codes, this should be tried before the less ambiguous elements. It may be helpful to develop a set of characters that can appear in a symbol or code, based on the currency symbols in the locale.</li>
<li>Otherwise, a character should be ignored unless it is in the "stop" set. This includes even characters that are meaningful for formatting, for example, the grouping separator.</li>
<li>If more than one sign, currency symbol, exponent, or percent/per mille occurs in the input, the first found should be used.</li>
<li>A currency symbol in the input should be interpreted as the longest match found in the set of possible currency symbols.</li>
<li>Especially in cases of ambiguity, the user's input should be echoed back, properly formatted according to the locale, before it is actually used for anything.</li>
</ul><hr><p>Copyright © 2001–2021 Unicode, Inc. All Rights Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and assumes no liability for errors or omissions. No liability is assumed for incidental and consequential damages in connection with or arising out of the use of the information or programs contained or accompanying this technical report. The Unicode <a href="https://unicode.org/copyright.html">Terms of Use</a> apply.</p><p>Unicode and the Unicode logo are trademarks of Unicode, Inc., and are registered in some jurisdictions.</p></div></body></html>